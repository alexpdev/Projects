{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"torrentfile Bittorrent File Creator (.torrent) TorrentFile can create torrent files, Check content for accuracy and completeness with a .torrent file, and display detailed information contained in a .torrent file. Features Create meta files for Bittorrent v1, v2 and hybrid torrent files. Display detailed information contained in torrent file. Check/ReCheck content and torrent file for download completion details and data integrity. Supports all .torrent files. GUI project can be found at https://github.com/alexpdev/TorrentfileQt Documentation Documentation can be found in the ./docs directory, or online at https://alexpdev.github.io/torrentfile . Installation via PyPi pip install torrentfile via Git ```bash: git clone https://github.com/alexpdev/torrentfile.git python setup.py install ### download Or download the latest release from the Release page on github. [https://github.com/alexpdev/torrentfile/releases](https://github.com/alexpdev/torrentfile/releases) ## CLI Help Message ```bash: usage: TorrentFile [-h] [-v] [-d] [-p] [-s <source>] [-c <comment>] [-o <path>] [--meta-version <int>] [-l <int>] [-a <url> [<url> ...]] [-r <.torrent>] <content> Create and/or ReCheck Bittorrent V1, V2, and Hybrid meta files. positional arguments: <content> path to content file or directory optional arguments: -h, --help show this help message and exit -v, --version show program version and exit -d, --debug output debug information -p, --private create file for private tracker -s <source>, --source <source> specify source tracker -c <comment>, --comment <comment> include a comment in file metadata -o <path>, --out <path> output path for created .torrent file --meta-version <int> torrent file version. Options = 1, 2 or 3. (1) = Bittorrent v1 (Default) (2) = Bittorrent v2 (3) = Bittorrent v1 & v2 hybrid -l <int>, --piece-length <int> Fixed amount of bytes for each chunk of data. (Default: None) Acceptable input values include integers 14-24, which will be interpreted as the exponent for 2^n, or any perfect power of two integer between 16Kib and 16MiB (inclusive). Examples:: [--piece-length 14] [-l 20] [-l 16777216] -a <url> [<url> ...], --announce <url> [<url> ...] one or more Bittorrent tracker announce url(s) Examples: [-a url1 url2 url3] [--anounce url1] -r <.torrent>, --check <.torrent>, --recheck <.torrent> <.torrent> is the path to a .torrent meta file. Check <content> data integrity with <.torrent> file. If this is active, all other options are ignored (except --debug) License Distributed under the GNU LGPL v3. See LICENSE for more information. https://github.com/alexpdev","title":"torrentfile"},{"location":"#torrentfile","text":"","title":"torrentfile"},{"location":"#bittorrent-file-creator-torrent","text":"TorrentFile can create torrent files, Check content for accuracy and completeness with a .torrent file, and display detailed information contained in a .torrent file.","title":"Bittorrent File Creator (.torrent)"},{"location":"#features","text":"Create meta files for Bittorrent v1, v2 and hybrid torrent files. Display detailed information contained in torrent file. Check/ReCheck content and torrent file for download completion details and data integrity. Supports all .torrent files. GUI project can be found at https://github.com/alexpdev/TorrentfileQt","title":"Features"},{"location":"#documentation","text":"Documentation can be found in the ./docs directory, or online at https://alexpdev.github.io/torrentfile .","title":"Documentation"},{"location":"#installation","text":"","title":"Installation"},{"location":"#via-pypi","text":"pip install torrentfile","title":"via PyPi"},{"location":"#via-git","text":"```bash: git clone https://github.com/alexpdev/torrentfile.git python setup.py install ### download Or download the latest release from the Release page on github. [https://github.com/alexpdev/torrentfile/releases](https://github.com/alexpdev/torrentfile/releases) ## CLI Help Message ```bash: usage: TorrentFile [-h] [-v] [-d] [-p] [-s <source>] [-c <comment>] [-o <path>] [--meta-version <int>] [-l <int>] [-a <url> [<url> ...]] [-r <.torrent>] <content> Create and/or ReCheck Bittorrent V1, V2, and Hybrid meta files. positional arguments: <content> path to content file or directory optional arguments: -h, --help show this help message and exit -v, --version show program version and exit -d, --debug output debug information -p, --private create file for private tracker -s <source>, --source <source> specify source tracker -c <comment>, --comment <comment> include a comment in file metadata -o <path>, --out <path> output path for created .torrent file --meta-version <int> torrent file version. Options = 1, 2 or 3. (1) = Bittorrent v1 (Default) (2) = Bittorrent v2 (3) = Bittorrent v1 & v2 hybrid -l <int>, --piece-length <int> Fixed amount of bytes for each chunk of data. (Default: None) Acceptable input values include integers 14-24, which will be interpreted as the exponent for 2^n, or any perfect power of two integer between 16Kib and 16MiB (inclusive). Examples:: [--piece-length 14] [-l 20] [-l 16777216] -a <url> [<url> ...], --announce <url> [<url> ...] one or more Bittorrent tracker announce url(s) Examples: [-a url1 url2 url3] [--anounce url1] -r <.torrent>, --check <.torrent>, --recheck <.torrent> <.torrent> is the path to a .torrent meta file. Check <content> data integrity with <.torrent> file. If this is active, all other options are ignored (except --debug)","title":"via Git"},{"location":"#license","text":"Distributed under the GNU LGPL v3. See LICENSE for more information. https://github.com/alexpdev","title":"License"},{"location":"cli/","text":"Documentation for CLI Module Command Line Interface for TorrentFile project. This module provides the primary command line argument parser for the torrentfile package. The main_script function is automatically invoked when called from command line, and parses accompanying arguments. Functions main_script: process command line arguments and run program. HelpFormat ( HelpFormatter ) Formatting class for help tips provided by the CLI. Parameters: Name Type Description Default prog `str` Name of the program. required width `int` Max width of help message output. required max_help_positions `int` max length until line wrap. required __init__ ( self , prog , width = 75 , max_help_pos = 40 ) special Construct HelpFormat class. Source code in torrentfile\\cli.py def __init__ ( self , prog , width = 75 , max_help_pos = 40 ): \"\"\"Construct HelpFormat class.\"\"\" super () . __init__ ( prog , width = width , max_help_position = max_help_pos ) main () Initiate main function for CLI script. Source code in torrentfile\\cli.py def main (): \"\"\"Initiate main function for CLI script.\"\"\" main_script () main_script ( args = None ) Initialize Command Line Interface for torrentfile. Parameters: Name Type Description Default args `list`, default=None Commandline arguments. None Source code in torrentfile\\cli.py def main_script ( args = None ): \"\"\"Initialize Command Line Interface for torrentfile. Args: args (`list`, default=None): Commandline arguments. \"\"\" if not args : args = sys . argv [ 1 :] desc = \"Create and/or ReCheck Bittorrent V1, V2, and Hybrid meta files.\" parser = ArgumentParser ( \"TorrentFile\" , description = desc , prefix_chars = \"-\" , formatter_class = HelpFormat , ) parser . add_argument ( \"-v\" , \"--version\" , action = \"version\" , version = f \"torrentfile v { torrentfile . __version__ } \" , help = \"show program version and exit\" , ) parser . add_argument ( \"-d\" , \"--debug\" , action = \"store_true\" , dest = \"debug\" , help = \"output debug information\" , ) parser . add_argument ( \"-p\" , \"--private\" , action = \"store_true\" , dest = \"private\" , help = \"create file for private tracker\" , ) parser . add_argument ( \"-s\" , \"--source\" , action = \"store\" , dest = \"source\" , metavar = \"<source>\" , help = \"specify source tracker\" , ) parser . add_argument ( \"-c\" , \"--comment\" , action = \"store\" , dest = \"comment\" , metavar = \"<comment>\" , help = \"include a comment in file metadata\" , ) parser . add_argument ( \"-o\" , \"--out\" , action = \"store\" , dest = \"outfile\" , metavar = \"<path>\" , help = \"output path for created .torrent file\" , ) parser . add_argument ( \"--meta-version\" , default = \"1\" , choices = [ \"1\" , \"2\" , \"3\" ], action = \"store\" , dest = \"meta_version\" , metavar = \"<int>\" , help = \"\"\" Bittorrent metafile version. Options = 1, 2 or 3. (1) = Bittorrent v1 (Default) (2) = Bittorrent v2 (3) = Bittorrent v1 & v2 hybrid \"\"\" , ) parser . add_argument ( \"-l\" , \"--piece-length\" , action = \"store\" , dest = \"piece_length\" , metavar = \"<int>\" , help = \"\"\" Fixed amount of bytes for each chunk of data. (Default: None) Acceptable input values include integers 14-24, which will be interpreted as the exponent for 2^n, or any perfect power of two integer between 16Kib and 16MiB (inclusive). Examples:: [--piece-length 14] [-l 20] [-l 16777216] \"\"\" , ) parser . add_argument ( \"-t\" , \"--tracker\" , action = \"store\" , dest = \"announce\" , metavar = \"<url>\" , nargs = \"+\" , default = \"\" , help = \"\"\" one or more Bittorrent tracker announce url(s) Examples:: [-a url1 url2 url3] [--anounce url1] \"\"\" , ) parser . add_argument ( \"-r\" , \"--check\" , \"--recheck\" , dest = \"checker\" , metavar = \"<.torrent>\" , help = \"\"\" <.torrent> is the path to a .torrent meta file. Check <content> data integrity with <.torrent> file. If this is active, all other options are ignored (except --debug) \"\"\" , ) parser . add_argument ( \"content\" , action = \"store\" , metavar = \"<content>\" , help = \"path to content file or directory\" , ) if not args : args = [ \"-h\" ] flags = parser . parse_args ( args ) if flags . debug : level = logging . DEBUG else : level = logging . WARNING logging . basicConfig ( level = level , format = \" %(prog)s %(asctime)s %(message)s \" , datefmt = \"%m- %d -%Y %H:%M:%S\" , ) if flags . checker : metafile = flags . checker content = flags . content checker = Checker ( metafile , content ) result = checker . result sys . stdout . write ( str ( result )) sys . stdout . flush () return result kwargs = { \"path\" : flags . content , \"announce\" : flags . announce , \"piece_length\" : flags . piece_length , \"source\" : flags . source , \"private\" : flags . private , \"outfile\" : flags . outfile , \"comment\" : flags . comment , } if flags . meta_version == \"2\" : torrent = TorrentFileV2 ( ** kwargs ) elif flags . meta_version == \"3\" : torrent = TorrentFileHybrid ( ** kwargs ) else : torrent = TorrentFile ( ** kwargs ) outfile , meta = torrent . write () parser . kwargs = kwargs parser . meta = meta parser . outfile = outfile return parser module torrentfile. cli Command Line Interface for TorrentFile project. This module provides the primary command line argument parser for the torrentfile package. The main_script function is automatically invoked when called from command line, and parses accompanying arguments. Functions: main_script: process command line arguments and run program. Classes HelpFormat \u2014 Formatting class for help tips provided by the CLI. Functions main ( ) \u2014 Initiate main function for CLI script. main_script ( args ) \u2014 Initialize Command Line Interface for torrentfile.","title":"Documentation for `CLI` Module"},{"location":"cli/#documentation-for-cli-module","text":"Command Line Interface for TorrentFile project. This module provides the primary command line argument parser for the torrentfile package. The main_script function is automatically invoked when called from command line, and parses accompanying arguments. Functions main_script: process command line arguments and run program.","title":"Documentation for CLI Module"},{"location":"cli/#torrentfile.cli.HelpFormat","text":"Formatting class for help tips provided by the CLI. Parameters: Name Type Description Default prog `str` Name of the program. required width `int` Max width of help message output. required max_help_positions `int` max length until line wrap. required","title":"HelpFormat"},{"location":"cli/#torrentfile.cli.HelpFormat.__init__","text":"Construct HelpFormat class. Source code in torrentfile\\cli.py def __init__ ( self , prog , width = 75 , max_help_pos = 40 ): \"\"\"Construct HelpFormat class.\"\"\" super () . __init__ ( prog , width = width , max_help_position = max_help_pos )","title":"__init__()"},{"location":"cli/#torrentfile.cli.main","text":"Initiate main function for CLI script. Source code in torrentfile\\cli.py def main (): \"\"\"Initiate main function for CLI script.\"\"\" main_script ()","title":"main()"},{"location":"cli/#torrentfile.cli.main_script","text":"Initialize Command Line Interface for torrentfile. Parameters: Name Type Description Default args `list`, default=None Commandline arguments. None Source code in torrentfile\\cli.py def main_script ( args = None ): \"\"\"Initialize Command Line Interface for torrentfile. Args: args (`list`, default=None): Commandline arguments. \"\"\" if not args : args = sys . argv [ 1 :] desc = \"Create and/or ReCheck Bittorrent V1, V2, and Hybrid meta files.\" parser = ArgumentParser ( \"TorrentFile\" , description = desc , prefix_chars = \"-\" , formatter_class = HelpFormat , ) parser . add_argument ( \"-v\" , \"--version\" , action = \"version\" , version = f \"torrentfile v { torrentfile . __version__ } \" , help = \"show program version and exit\" , ) parser . add_argument ( \"-d\" , \"--debug\" , action = \"store_true\" , dest = \"debug\" , help = \"output debug information\" , ) parser . add_argument ( \"-p\" , \"--private\" , action = \"store_true\" , dest = \"private\" , help = \"create file for private tracker\" , ) parser . add_argument ( \"-s\" , \"--source\" , action = \"store\" , dest = \"source\" , metavar = \"<source>\" , help = \"specify source tracker\" , ) parser . add_argument ( \"-c\" , \"--comment\" , action = \"store\" , dest = \"comment\" , metavar = \"<comment>\" , help = \"include a comment in file metadata\" , ) parser . add_argument ( \"-o\" , \"--out\" , action = \"store\" , dest = \"outfile\" , metavar = \"<path>\" , help = \"output path for created .torrent file\" , ) parser . add_argument ( \"--meta-version\" , default = \"1\" , choices = [ \"1\" , \"2\" , \"3\" ], action = \"store\" , dest = \"meta_version\" , metavar = \"<int>\" , help = \"\"\" Bittorrent metafile version. Options = 1, 2 or 3. (1) = Bittorrent v1 (Default) (2) = Bittorrent v2 (3) = Bittorrent v1 & v2 hybrid \"\"\" , ) parser . add_argument ( \"-l\" , \"--piece-length\" , action = \"store\" , dest = \"piece_length\" , metavar = \"<int>\" , help = \"\"\" Fixed amount of bytes for each chunk of data. (Default: None) Acceptable input values include integers 14-24, which will be interpreted as the exponent for 2^n, or any perfect power of two integer between 16Kib and 16MiB (inclusive). Examples:: [--piece-length 14] [-l 20] [-l 16777216] \"\"\" , ) parser . add_argument ( \"-t\" , \"--tracker\" , action = \"store\" , dest = \"announce\" , metavar = \"<url>\" , nargs = \"+\" , default = \"\" , help = \"\"\" one or more Bittorrent tracker announce url(s) Examples:: [-a url1 url2 url3] [--anounce url1] \"\"\" , ) parser . add_argument ( \"-r\" , \"--check\" , \"--recheck\" , dest = \"checker\" , metavar = \"<.torrent>\" , help = \"\"\" <.torrent> is the path to a .torrent meta file. Check <content> data integrity with <.torrent> file. If this is active, all other options are ignored (except --debug) \"\"\" , ) parser . add_argument ( \"content\" , action = \"store\" , metavar = \"<content>\" , help = \"path to content file or directory\" , ) if not args : args = [ \"-h\" ] flags = parser . parse_args ( args ) if flags . debug : level = logging . DEBUG else : level = logging . WARNING logging . basicConfig ( level = level , format = \" %(prog)s %(asctime)s %(message)s \" , datefmt = \"%m- %d -%Y %H:%M:%S\" , ) if flags . checker : metafile = flags . checker content = flags . content checker = Checker ( metafile , content ) result = checker . result sys . stdout . write ( str ( result )) sys . stdout . flush () return result kwargs = { \"path\" : flags . content , \"announce\" : flags . announce , \"piece_length\" : flags . piece_length , \"source\" : flags . source , \"private\" : flags . private , \"outfile\" : flags . outfile , \"comment\" : flags . comment , } if flags . meta_version == \"2\" : torrent = TorrentFileV2 ( ** kwargs ) elif flags . meta_version == \"3\" : torrent = TorrentFileHybrid ( ** kwargs ) else : torrent = TorrentFile ( ** kwargs ) outfile , meta = torrent . write () parser . kwargs = kwargs parser . meta = meta parser . outfile = outfile return parser module torrentfile. cli Command Line Interface for TorrentFile project. This module provides the primary command line argument parser for the torrentfile package. The main_script function is automatically invoked when called from command line, and parses accompanying arguments. Functions: main_script: process command line arguments and run program. Classes HelpFormat \u2014 Formatting class for help tips provided by the CLI. Functions main ( ) \u2014 Initiate main function for CLI script. main_script ( args ) \u2014 Initialize Command Line Interface for torrentfile.","title":"main_script()"},{"location":"hasher/","text":"Documentation for Hasher Module Piece/File Hashers for Bittorrent meta file contents. Hasher Piece hasher for Bittorrent V1 files. Takes a sorted list of all file paths, calculates sha1 hash for fixed size pieces of file data from each file seemlessly until the last piece which may be smaller than others. Parameters: Name Type Description Default paths `list` List of files. required piece_length `int` Size of chuncks to split the data into. required total `int` Sum of all files in file list. required __init__ ( self , paths , piece_length ) special Generate hashes of piece length data from filelist contents. Source code in torrentfile\\hasher.py def __init__ ( self , paths , piece_length ): \"\"\"Generate hashes of piece length data from filelist contents.\"\"\" self . piece_length = piece_length self . paths = paths self . total = sum ([ os . path . getsize ( i ) for i in self . paths ]) self . index = 0 self . current = open ( self . paths [ 0 ], \"rb\" ) logging . debug ( \"Hashing v1 torrent file. Size: %s Piece Length: %s \" , humanize_bytes ( self . total ), humanize_bytes ( self . piece_length ), ) __iter__ ( self ) special Iterate through feed pieces. Returns: Type Description self (`iterator`) Iterator for leaves/hash pieces. Source code in torrentfile\\hasher.py def __iter__ ( self ): \"\"\"Iterate through feed pieces. Returns: self (`iterator`): Iterator for leaves/hash pieces. \"\"\" return self __next__ ( self ) special Generate piece-length pieces of data from input file list. Source code in torrentfile\\hasher.py def __next__ ( self ): \"\"\"Generate piece-length pieces of data from input file list.\"\"\" while True : piece = bytearray ( self . piece_length ) size = self . current . readinto ( piece ) if size == 0 : if not self . next_file (): raise StopIteration elif size < self . piece_length : return self . _handle_partial ( piece [: size ]) else : return sha1 ( piece ) . digest () # nosec next_file ( self ) Seemlessly transition to next file in file list. Source code in torrentfile\\hasher.py def next_file ( self ): \"\"\"Seemlessly transition to next file in file list.\"\"\" self . index += 1 if self . index < len ( self . paths ): self . current . close () self . current = open ( self . paths [ self . index ], \"rb\" ) return True return False HasherHybrid Calculate hashes for Hybrid torrentfile. Uses sha1 and sha256 hashes for each version # nosec of the Bittorrent protocols meta files respectively. Parameters: Name Type Description Default path `str` path to target file. required piece_length `int` piece length for data chunks. required __init__ ( self , path , piece_length ) special Construct Hasher class instances for each file in torrent. Source code in torrentfile\\hasher.py def __init__ ( self , path , piece_length ): \"\"\"Construct Hasher class instances for each file in torrent.\"\"\" self . path = path self . piece_length = piece_length self . pieces = [] self . layer_hashes = [] self . piece_layer = None self . root = None self . padding_piece = None self . padding_file = None self . amount = piece_length // BLOCK_SIZE logging . debug ( \"Hashing partial Hybrid torrent file. Piece Length: %s Path: %s \" , humanize_bytes ( self . piece_length ), str ( self . path ), ) with open ( path , \"rb\" ) as data : self . _process_file ( data ) calculate_root ( self ) Calculate the root hash for opened file. Source code in torrentfile\\hasher.py def calculate_root ( self ): \"\"\"Calculate the root hash for opened file.\"\"\" self . piece_layer = b \"\" . join ( self . layer_hashes ) if len ( self . layer_hashes ) > 1 : pad_piece = merkle_root ([ bytes ( 32 ) for _ in range ( self . amount )]) next_pow_two = 1 << ( len ( self . layer_hashes ) - 1 ) . bit_length () remainder = next_pow_two - len ( self . layer_hashes ) self . layer_hashes += [ pad_piece for _ in range ( remainder )] self . root = merkle_root ( self . layer_hashes ) HasherV2 Calculate the root hash and piece layers for file contents. Iterates over 16KiB blocks of data from given file, hashes the data, then creates a hash tree from the individual block hashes until size of hashed data equals the piece-length. Then continues the hash tree until root hash is calculated. Parameters: Name Type Description Default path `str` Path to file. required piece_length `int` Size of layer hashes pieces. required __init__ ( self , path , piece_length ) special Calculate and store hash information for specific file. Source code in torrentfile\\hasher.py def __init__ ( self , path , piece_length ): \"\"\"Calculate and store hash information for specific file.\"\"\" self . path = path self . root = None self . piece_layer = None self . layer_hashes = [] self . piece_length = piece_length self . num_blocks = piece_length // BLOCK_SIZE logging . debug ( \"Hashing partial v2 torrent file. Piece Length: %s Path: %s \" , humanize_bytes ( self . piece_length ), str ( self . path ), ) with open ( self . path , \"rb\" ) as fd : self . process_file ( fd ) process_file ( self , fd ) Calculate hashes over 16KiB chuncks of file content. Parameters: Name Type Description Default fd `str` Opened file in read mode. required Source code in torrentfile\\hasher.py def process_file ( self , fd ): \"\"\"Calculate hashes over 16KiB chuncks of file content. Args: fd (`str`): Opened file in read mode. \"\"\" while True : total = 0 blocks = [] leaf = bytearray ( BLOCK_SIZE ) # generate leaves of merkle tree for _ in range ( self . num_blocks ): size = fd . readinto ( leaf ) total += size if not size : break blocks . append ( sha256 ( leaf [: size ]) . digest ()) # blocks is empty mean eof if not blocks : break if len ( blocks ) != self . num_blocks : if not self . layer_hashes : next_pow_2 = 1 << int ( math . log2 ( total ) + 1 ) remaining = (( next_pow_2 - total ) // BLOCK_SIZE ) + 1 else : remaining = self . num_blocks - size padding = [ bytes ( HASH_SIZE ) for _ in range ( remaining )] blocks . extend ( padding ) # if the file is smaller than piece length layer_hash = merkle_root ( blocks ) self . layer_hashes . append ( layer_hash ) self . _calculate_root () merkle_root ( blocks ) Calculate the merkle root for a seq of sha256 hash digests. Source code in torrentfile\\hasher.py def merkle_root ( blocks ): \"\"\"Calculate the merkle root for a seq of sha256 hash digests.\"\"\" while len ( blocks ) > 1 : blocks = [ sha256 ( x + y ) . digest () for x , y in zip ( * [ iter ( blocks )] * 2 )] return blocks [ 0 ] module torrentfile. hasher Piece/File Hashers for Bittorrent meta file contents. Classes Hasher \u2014 Piece hasher for Bittorrent V1 files. HasherV2 \u2014 Calculate the root hash and piece layers for file contents. HasherHybrid \u2014 Calculate hashes for Hybrid torrentfile. Functions merkle_root ( blocks ) \u2014 Calculate the merkle root for a seq of sha256 hash digests.","title":"Documentation for `Hasher` Module"},{"location":"hasher/#documentation-for-hasher-module","text":"Piece/File Hashers for Bittorrent meta file contents.","title":"Documentation for Hasher Module"},{"location":"hasher/#torrentfile.hasher.Hasher","text":"Piece hasher for Bittorrent V1 files. Takes a sorted list of all file paths, calculates sha1 hash for fixed size pieces of file data from each file seemlessly until the last piece which may be smaller than others. Parameters: Name Type Description Default paths `list` List of files. required piece_length `int` Size of chuncks to split the data into. required total `int` Sum of all files in file list. required","title":"Hasher"},{"location":"hasher/#torrentfile.hasher.Hasher.__init__","text":"Generate hashes of piece length data from filelist contents. Source code in torrentfile\\hasher.py def __init__ ( self , paths , piece_length ): \"\"\"Generate hashes of piece length data from filelist contents.\"\"\" self . piece_length = piece_length self . paths = paths self . total = sum ([ os . path . getsize ( i ) for i in self . paths ]) self . index = 0 self . current = open ( self . paths [ 0 ], \"rb\" ) logging . debug ( \"Hashing v1 torrent file. Size: %s Piece Length: %s \" , humanize_bytes ( self . total ), humanize_bytes ( self . piece_length ), )","title":"__init__()"},{"location":"hasher/#torrentfile.hasher.Hasher.__iter__","text":"Iterate through feed pieces. Returns: Type Description self (`iterator`) Iterator for leaves/hash pieces. Source code in torrentfile\\hasher.py def __iter__ ( self ): \"\"\"Iterate through feed pieces. Returns: self (`iterator`): Iterator for leaves/hash pieces. \"\"\" return self","title":"__iter__()"},{"location":"hasher/#torrentfile.hasher.Hasher.__next__","text":"Generate piece-length pieces of data from input file list. Source code in torrentfile\\hasher.py def __next__ ( self ): \"\"\"Generate piece-length pieces of data from input file list.\"\"\" while True : piece = bytearray ( self . piece_length ) size = self . current . readinto ( piece ) if size == 0 : if not self . next_file (): raise StopIteration elif size < self . piece_length : return self . _handle_partial ( piece [: size ]) else : return sha1 ( piece ) . digest () # nosec","title":"__next__()"},{"location":"hasher/#torrentfile.hasher.Hasher.next_file","text":"Seemlessly transition to next file in file list. Source code in torrentfile\\hasher.py def next_file ( self ): \"\"\"Seemlessly transition to next file in file list.\"\"\" self . index += 1 if self . index < len ( self . paths ): self . current . close () self . current = open ( self . paths [ self . index ], \"rb\" ) return True return False","title":"next_file()"},{"location":"hasher/#torrentfile.hasher.HasherHybrid","text":"Calculate hashes for Hybrid torrentfile. Uses sha1 and sha256 hashes for each version # nosec of the Bittorrent protocols meta files respectively. Parameters: Name Type Description Default path `str` path to target file. required piece_length `int` piece length for data chunks. required","title":"HasherHybrid"},{"location":"hasher/#torrentfile.hasher.HasherHybrid.__init__","text":"Construct Hasher class instances for each file in torrent. Source code in torrentfile\\hasher.py def __init__ ( self , path , piece_length ): \"\"\"Construct Hasher class instances for each file in torrent.\"\"\" self . path = path self . piece_length = piece_length self . pieces = [] self . layer_hashes = [] self . piece_layer = None self . root = None self . padding_piece = None self . padding_file = None self . amount = piece_length // BLOCK_SIZE logging . debug ( \"Hashing partial Hybrid torrent file. Piece Length: %s Path: %s \" , humanize_bytes ( self . piece_length ), str ( self . path ), ) with open ( path , \"rb\" ) as data : self . _process_file ( data )","title":"__init__()"},{"location":"hasher/#torrentfile.hasher.HasherHybrid.calculate_root","text":"Calculate the root hash for opened file. Source code in torrentfile\\hasher.py def calculate_root ( self ): \"\"\"Calculate the root hash for opened file.\"\"\" self . piece_layer = b \"\" . join ( self . layer_hashes ) if len ( self . layer_hashes ) > 1 : pad_piece = merkle_root ([ bytes ( 32 ) for _ in range ( self . amount )]) next_pow_two = 1 << ( len ( self . layer_hashes ) - 1 ) . bit_length () remainder = next_pow_two - len ( self . layer_hashes ) self . layer_hashes += [ pad_piece for _ in range ( remainder )] self . root = merkle_root ( self . layer_hashes )","title":"calculate_root()"},{"location":"hasher/#torrentfile.hasher.HasherV2","text":"Calculate the root hash and piece layers for file contents. Iterates over 16KiB blocks of data from given file, hashes the data, then creates a hash tree from the individual block hashes until size of hashed data equals the piece-length. Then continues the hash tree until root hash is calculated. Parameters: Name Type Description Default path `str` Path to file. required piece_length `int` Size of layer hashes pieces. required","title":"HasherV2"},{"location":"hasher/#torrentfile.hasher.HasherV2.__init__","text":"Calculate and store hash information for specific file. Source code in torrentfile\\hasher.py def __init__ ( self , path , piece_length ): \"\"\"Calculate and store hash information for specific file.\"\"\" self . path = path self . root = None self . piece_layer = None self . layer_hashes = [] self . piece_length = piece_length self . num_blocks = piece_length // BLOCK_SIZE logging . debug ( \"Hashing partial v2 torrent file. Piece Length: %s Path: %s \" , humanize_bytes ( self . piece_length ), str ( self . path ), ) with open ( self . path , \"rb\" ) as fd : self . process_file ( fd )","title":"__init__()"},{"location":"hasher/#torrentfile.hasher.HasherV2.process_file","text":"Calculate hashes over 16KiB chuncks of file content. Parameters: Name Type Description Default fd `str` Opened file in read mode. required Source code in torrentfile\\hasher.py def process_file ( self , fd ): \"\"\"Calculate hashes over 16KiB chuncks of file content. Args: fd (`str`): Opened file in read mode. \"\"\" while True : total = 0 blocks = [] leaf = bytearray ( BLOCK_SIZE ) # generate leaves of merkle tree for _ in range ( self . num_blocks ): size = fd . readinto ( leaf ) total += size if not size : break blocks . append ( sha256 ( leaf [: size ]) . digest ()) # blocks is empty mean eof if not blocks : break if len ( blocks ) != self . num_blocks : if not self . layer_hashes : next_pow_2 = 1 << int ( math . log2 ( total ) + 1 ) remaining = (( next_pow_2 - total ) // BLOCK_SIZE ) + 1 else : remaining = self . num_blocks - size padding = [ bytes ( HASH_SIZE ) for _ in range ( remaining )] blocks . extend ( padding ) # if the file is smaller than piece length layer_hash = merkle_root ( blocks ) self . layer_hashes . append ( layer_hash ) self . _calculate_root ()","title":"process_file()"},{"location":"hasher/#torrentfile.hasher.merkle_root","text":"Calculate the merkle root for a seq of sha256 hash digests. Source code in torrentfile\\hasher.py def merkle_root ( blocks ): \"\"\"Calculate the merkle root for a seq of sha256 hash digests.\"\"\" while len ( blocks ) > 1 : blocks = [ sha256 ( x + y ) . digest () for x , y in zip ( * [ iter ( blocks )] * 2 )] return blocks [ 0 ] module torrentfile. hasher Piece/File Hashers for Bittorrent meta file contents. Classes Hasher \u2014 Piece hasher for Bittorrent V1 files. HasherV2 \u2014 Calculate the root hash and piece layers for file contents. HasherHybrid \u2014 Calculate hashes for Hybrid torrentfile. Functions merkle_root ( blocks ) \u2014 Calculate the merkle root for a seq of sha256 hash digests.","title":"merkle_root()"},{"location":"recheck/","text":"Documentation for Recheck Module Module container Checker Class. The CheckerClass takes a torrentfile and tha path to it's contents. It will then iterate through every file and directory contained and compare their data to values contained within the torrent file. Completion percentages will be printed to screen for each file and at the end for the torrentfile as a whole. Checker Check a given file or directory to see if it matches a torrentfile. Public constructor for Checker class instance. Parameters: Name Type Description Default metafile `str` Path to \".torrent\" file. required location `str` Path where the content is located in filesystem. required Examples: metafile = \"/path/to/torrentfile/content_file_or_dir.torrent\" location = \"/path/to/location\" os.path.exists(\"/path/to/location/content_file_or_dir\") Out: True checker = Checker(metafile, location) result property readonly Generate result percentage and store for future calls. __init__ ( self , metafile , path ) special Validate data against hashes contained in .torrent file. Parameters: Name Type Description Default metafile `str` path to .torrent file required path `str` path to content or contents parent directory. required Source code in torrentfile\\recheck.py def __init__ ( self , metafile , path ): \"\"\"Validate data against hashes contained in .torrent file. Args: metafile (`str`): path to .torrent file path (`str`): path to content or contents parent directory. \"\"\" self . _result = None self . meta_version = None self . metafile = metafile self . last_log = None self . log_msg ( \"Checking: %s , %s \" , metafile , path ) self . info = self . parse_metafile () self . name = self . info [ \"name\" ] self . piece_length = self . info [ \"piece length\" ] self . root = self . find_root ( path ) self . total = 0 self . paths = [] self . fileinfo = {} self . check_paths () check_paths ( self ) Gather all file paths described in the torrent file. Source code in torrentfile\\recheck.py def check_paths ( self ): \"\"\"Gather all file paths described in the torrent file.\"\"\" if os . path . isfile ( self . root ): self . log_msg ( \" %s points to a single file\" , self . root ) self . paths . append ( self . root ) if self . meta_version == 1 : self . fileinfo [ self . root ] = { \"length\" : self . info [ \"length\" ]} self . total = self . info [ \"length\" ] self . pieces = split_pieces ( self . info [ \"pieces\" ], SHA1 ) else : info = self . info [ \"file tree\" ][ self . name ][ \"\" ] info [ \"partial\" ] = self . name self . total = info [ \"length\" ] if self . total > self . piece_length : layers = self . info [ \"piece layers\" ][ info [ \"pieces root\" ]] info [ \"layer hashes\" ] = split_pieces ( layers , SHA256 ) self . fileinfo [ self . root ] = info return # Otherwise Content is more than 1 file. self . log_msg ( \" %s points to a directory\" , self . root ) if self . meta_version == 1 : for path in self . info [ \"files\" ]: self . total += path [ \"length\" ] rlpath = os . path . join ( * path [ \"path\" ]) full = os . path . join ( self . root , rlpath ) self . log_msg ( \"Including file path: %s \" , rlpath ) self . fileinfo [ full ] = { \"length\" : path [ \"length\" ]} self . paths . append ( full ) # Split pieces into individual hash digests. self . pieces = split_pieces ( self . info [ \"pieces\" ], SHA1 ) return self . walk_file_tree ( self . info [ \"file tree\" ], []) find_root ( self , path ) Check path for torrent content. The path can be a relative or absolute filesystem path. In the case where the content is a single file, the path may point directly to the the file, or it may point to the parent directory. If content points to a directory. The directory will be checked to see if it matches the torrent's name, if not the directories contents will be searched. The returned value will be the absolute path that matches the torrent's name. Returns: Type Description `str` root path to content Source code in torrentfile\\recheck.py def find_root ( self , path ): \"\"\"Check path for torrent content. The path can be a relative or absolute filesystem path. In the case where the content is a single file, the path may point directly to the the file, or it may point to the parent directory. If content points to a directory. The directory will be checked to see if it matches the torrent's name, if not the directories contents will be searched. The returned value will be the absolute path that matches the torrent's name. Returns: `str`: root path to content \"\"\" if not os . path . exists ( path ): self . log_msg ( \"Could not locate torrent content %s .\" , path ) raise FileNotFoundError ( path ) root = os . path . abspath ( path ) base = os . path . basename ( root ) if base == self . name : self . log_msg ( \"Content found: %s .\" , root ) return root self . log_msg ( \"Searching for torrent root in %s \" , root ) for name in os . listdir ( root ): if name == self . name : root = os . path . join ( root , name ) self . log_msg ( \"Content Found: %s \" , root ) return root self . log_msg ( \"Could not locate torrent content in: %s \" , root ) raise FileNotFoundError ( root ) iter_hashes ( self ) Produce results of comparing torrent contents piece by piece. Returns: Type Description chunck (`bytes`) hash of data found on disk piece ( bytes ): hash of data when complete and correct path ( str ): path to file being hashed size ( int ): length of bytes hashed for piece Source code in torrentfile\\recheck.py def iter_hashes ( self ): \"\"\"Produce results of comparing torrent contents piece by piece. Returns: chunck (`bytes`): hash of data found on disk piece (`bytes`): hash of data when complete and correct path (`str`): path to file being hashed size (`int`): length of bytes hashed for piece \"\"\" matched = consumed = 0 if self . meta_version == 1 : checker = FeedChecker args = ( self . paths , self . piece_length , self . fileinfo , self . pieces ) else : checker = HashChecker hasher = HasherV2 if self . meta_version == 2 else HasherHybrid args = ( self . paths , self . piece_length , self . fileinfo , hasher ) for chunk , piece , path , size in checker ( * args ): consumed += size msg = \"Match %s : %s %s \" humansize = humanize_bytes ( size ) if chunk == piece : matched += size logging . debug ( msg , \"Success\" , path , humansize ) else : logging . debug ( msg , \"Fail\" , path , humansize ) yield chunk , piece , path , size total_consumed = str ( int ( consumed / self . total * 100 )) percent_matched = str ( int ( matched / consumed * 100 )) self . log_msg ( \"Processed: %s%% , Matched: %s%% \" , total_consumed , percent_matched , ) if consumed : self . log_msg ( \"Re-Check Complete: \\n %s%% of %s found at %s \" , percent_matched , self . metafile , self . root , ) self . _result = percent_matched else : # pragma: no cover self . log_msg ( \"Re-Check Complete: \\n 0 %% of %s found at %s \" , self . metafile , self . root , ) self . _result = \"0\" log_msg ( self , * args , * , level = 20 ) Log message msg to logger and send msg to callback hook. Parameters: Name Type Description Default `*args` `Iterable`[`str`] formatting args for log message required level `int`, default=`logging.INFO`) Log level for this message 20 Source code in torrentfile\\recheck.py def log_msg ( self , * args , level = logging . INFO ): \"\"\"Log message `msg` to logger and send `msg` to callback hook. Args: `*args` (`Iterable`[`str`]): formatting args for log message level (`int`, default=`logging.INFO`) : Log level for this message \"\"\" message = args [ 0 ] if len ( args ) >= 3 : message = message % tuple ( args [ 1 :]) elif len ( args ) == 2 : message = message % args [ 1 ] # Repeat log messages should be ignored. if message != self . last_log : self . last_log = message logging . log ( level , message ) if self . _hook and level == logging . INFO : self . _hook ( message ) parse_metafile ( self ) Flatten Meta dictionary of torrent file. Returns: Type Description `dict` flattened meta dictionary. Source code in torrentfile\\recheck.py def parse_metafile ( self ): \"\"\"Flatten Meta dictionary of torrent file. Returns: `dict`: flattened meta dictionary. \"\"\" if not os . path . exists ( self . metafile ): self . log_msg ( \"File %s could not be found.\" , self . metafile ) raise FileNotFoundError ( self . metafile ) info = {} has_pieces = has_meta_version = False for k , v in pyben . load ( self . metafile ) . items (): if k == \"info\" : for key , val in v . items (): info [ key ] = val if key == \"pieces\" : has_pieces = True if key == \"meta version\" : has_meta_version = True else : info [ k ] = v if has_meta_version and has_pieces : self . meta_version = 3 elif has_meta_version : self . meta_version = 2 else : self . meta_version = 1 self . log_msg ( \"Detected Meta Version %s .\" , str ( self . meta_version )) return info register_callback ( hook ) classmethod Register hooks from 3rd party programs to access generated info. Parameters: Name Type Description Default hook `function` callback function for the logging feature. required Source code in torrentfile\\recheck.py @classmethod def register_callback ( cls , hook ): \"\"\"Register hooks from 3rd party programs to access generated info. Args: hook (`function`): callback function for the logging feature. \"\"\" cls . _hook = hook walk_file_tree ( self , tree , partials ) Traverse File Tree dictionary to get file details. Extract full pathnames, length, root hash, and layer hashes for each file included in the .torrent's file tree. Parameters: Name Type Description Default tree `dict` File Tree dict extracted from torrent file. required partials `list` list of intermediate pathnames. required Source code in torrentfile\\recheck.py def walk_file_tree ( self , tree , partials ): \"\"\"Traverse File Tree dictionary to get file details. Extract full pathnames, length, root hash, and layer hashes for each file included in the .torrent's file tree. Args: tree (`dict`): File Tree dict extracted from torrent file. partials (`list`): list of intermediate pathnames. \"\"\" for key , val in tree . items (): # Empty string means the tree's leaf is value if \"\" in val : path = os . path . join ( self . root , * partials , key ) info = self . fileinfo [ path ] = val [ \"\" ] info [ \"partial\" ] = key size = val [ \"\" ][ \"length\" ] # get layer hashes for this file if size > self . piece_length : root = val [ \"\" ][ \"pieces root\" ] layer_hashes = self . info [ \"piece layers\" ][ root ] info [ \"layer hashes\" ] = split_pieces ( layer_hashes , SHA256 ) self . paths . append ( path ) self . total += size self . log_msg ( \"Including: path - %s , length - %s \" , path , humanize_bytes ( size ), ) else : self . walk_file_tree ( val , partials + [ key ]) FeedChecker Validates torrent content. Seemlesly validate torrent file contents by comparing hashes in metafile against data on disk. Parameters: Name Type Description Default paths `list` List of stirngs indicating file paths. required piece_length `int` Size of data blocks to split the data into. required total `int` Sum total in bytes of all files in file list. required fileinfo `dict` Info and meta dictionary from .torrent file. required current_length property readonly Length of current file contents in bytes. __init__ ( self , paths , piece_length , fileinfo , pieces ) special Generate hashes of piece length data from filelist contents. Source code in torrentfile\\recheck.py def __init__ ( self , paths , piece_length , fileinfo , pieces ): \"\"\"Generate hashes of piece length data from filelist contents.\"\"\" self . piece_length = piece_length self . paths = paths self . pieces = pieces self . fileinfo = fileinfo self . piece_map = {} self . index = 0 self . piece_count = 0 self . itor = None __iter__ ( self ) special Assign iterator and return self. Source code in torrentfile\\recheck.py def __iter__ ( self ): \"\"\"Assign iterator and return self.\"\"\" self . itor = self . iter_pieces () return self __next__ ( self ) special Yield back result of comparison. Source code in torrentfile\\recheck.py def __next__ ( self ): \"\"\"Yield back result of comparison.\"\"\" partial = next ( self . itor ) chunck = sha1 ( partial ) . digest () # nosec try : piece = self . pieces [ self . piece_count ] except IndexError : raise StopIteration # pragma: no cover path = self . paths [ self . index ] self . piece_count += 1 return chunck , piece , path , len ( partial ) extract ( self , path , partial ) Split file paths contents into blocks of data for hash pieces. Parameters: Name Type Description Default path `str` path to content. required partial `bytes` any remaining content from last file. required Yields partial ( bytes ): Hash digest for block of .torrent contents. Source code in torrentfile\\recheck.py def extract ( self , path , partial ): \"\"\"Split file paths contents into blocks of data for hash pieces. Args: path (`str`): path to content. partial (`bytes`): any remaining content from last file. Yields: partial (`bytes`): Hash digest for block of .torrent contents. \"\"\" read = 0 size = os . path . getsize ( path ) length = self . fileinfo [ path ][ \"length\" ] with open ( path , \"rb\" ) as current : while True : bitlength = self . piece_length - len ( partial ) part = bytearray ( bitlength ) amount = current . readinto ( part ) read += amount partial . extend ( part [: amount ]) if amount < bitlength : if size == read == length : yield partial break yield partial partial = bytearray ( 0 ) while length - size > 0 : left = self . piece_length - len ( partial ) if length - size > left : padding = bytearray ( left ) size += left partial . extend ( padding ) yield partial partial = bytearray ( 0 ) else : partial . extend ( bytearray ( length - size )) size += length - size yield partial iter_pieces ( self ) Iterate through, and hash pieces of torrent contents. Yields piece ( bytes ): hash digest for block of torrent data. Source code in torrentfile\\recheck.py def iter_pieces ( self ): \"\"\"Iterate through, and hash pieces of torrent contents. Yields: piece (`bytes`): hash digest for block of torrent data. \"\"\" partial = bytearray () for i , path in enumerate ( self . paths ): self . index = i if os . path . exists ( path ): for piece in self . extract ( path , partial ): if len ( piece ) == self . piece_length : yield piece partial = bytearray () elif i + 1 == len ( self . paths ): yield piece else : partial = piece else : for blank in self . _gen_blanks ( partial ): if len ( blank ) == self . piece_length : yield blank partial = bytearray () else : partial = blank HashChecker Construct the HybridChecker. Verify that root hashes of content files match the .torrent files. Parameters: Name Type Description Default paths `list` List of files. required piece_length `int` Size of chuncks to split the data into. required fileinfo `dict` Info from .torrent file being checked. required __init__ ( self , paths , piece_length , fileinfo , hasher ) special Construct a HybridChecker instance. Source code in torrentfile\\recheck.py def __init__ ( self , paths , piece_length , fileinfo , hasher ): \"\"\"Construct a HybridChecker instance.\"\"\" self . paths = paths self . hasher = hasher self . piece_length = piece_length self . fileinfo = fileinfo self . itor = None logging . debug ( \"Starting Hash Checker. piece length: %s \" , humanize_bytes ( self . piece_length ), ) __iter__ ( self ) special Assign iterator and return self. Source code in torrentfile\\recheck.py def __iter__ ( self ): \"\"\"Assign iterator and return self.\"\"\" self . itor = self . iter_paths () return self __next__ ( self ) special Provide the result of comparison. Source code in torrentfile\\recheck.py def __next__ ( self ): \"\"\"Provide the result of comparison.\"\"\" try : value = next ( self . itor ) return value except StopIteration as stopiter : raise StopIteration () from stopiter iter_paths ( self ) Iterate through and compare root file hashes to .torrent file. Parameters: Name Type Description Default hasher class The class user to caluclate root hash. required Yields results ( tuple ): The size of the file and result of match. Source code in torrentfile\\recheck.py def iter_paths ( self ): \"\"\"Iterate through and compare root file hashes to .torrent file. Args: hasher (class): The class user to caluclate root hash. Yields: results (`tuple`): The size of the file and result of match. \"\"\" for path in self . paths : info = self . fileinfo [ path ] length = info [ \"length\" ] logging . debug ( \" %s length: %s \" , path , str ( length )) roothash = info [ \"pieces root\" ] logging . debug ( \" %s root hash %s \" , path , str ( roothash )) if not os . path . exists ( path ): if \"layer hashes\" in info and info [ \"layer hashes\" ]: pieces = info [ \"layer hashes\" ] else : pieces = [ roothash ] for i , piece in enumerate ( pieces ): if len ( pieces ) == 1 : size = length elif i < len ( pieces ) - 1 : size = self . piece_length else : size = length - (( len ( pieces ) - 1 ) * self . piece_length ) logging . debug ( \"Yielding: %s %s %s %s \" , str ( bytes ( SHA256 )), str ( piece ), path , str ( size ), ) yield bytes ( SHA256 ), piece , path , size continue hashed = self . hasher ( path , self . piece_length ) if \"layer hashes\" in info : hash_pieces = split_pieces ( hashed . piece_layer , SHA256 ) info_pieces = info [ \"layer hashes\" ] else : hash_pieces = [ hashed . root ] info_pieces = [ info [ \"pieces root\" ]] diff = len ( info_pieces ) - len ( hash_pieces ) if diff > 0 : hash_pieces += [ bytes ( SHA256 )] * diff num_pieces = len ( hash_pieces ) size = self . piece_length for chunk , piece in zip ( hash_pieces , info_pieces ): if num_pieces == 1 : size = length - (( len ( hash_pieces ) - 1 ) * size ) logging . debug ( \"Yielding: %s , %s , %s , %s \" , str ( chunk ), str ( piece ), str ( path ), str ( size ), ) yield chunk , piece , path , size num_pieces -= 1 split_pieces ( pieces , hash_size ) Split bytes into 20 piece chuncks for sha1 digest. Parameters: Name Type Description Default pieces `bytes` Initial data. required Returns: Type Description lst (`list`) Pieces broken into groups of 20 bytes. Source code in torrentfile\\recheck.py def split_pieces ( pieces , hash_size ): \"\"\"Split bytes into 20 piece chuncks for sha1 digest. Args: pieces (`bytes`): Initial data. Returns: lst (`list`): Pieces broken into groups of 20 bytes. \"\"\" lst = [] start = 0 while start < len ( pieces ): end = start + hash_size lst . append ( pieces [ start : end ]) start += hash_size return lst module torrentfile. recheck Module container Checker Class. The CheckerClass takes a torrentfile and tha path to it's contents. It will then iterate through every file and directory contained and compare their data to values contained within the torrent file. Completion percentages will be printed to screen for each file and at the end for the torrentfile as a whole. Classes Checker \u2014 Check a given file or directory to see if it matches a torrentfile. FeedChecker \u2014 Validates torrent content. HashChecker \u2014 Construct the HybridChecker. Functions split_pieces ( pieces , hash_size ) (lst (`list`)) \u2014 Split bytes into 20 piece chuncks for sha1 digest.","title":"Documentation for `Recheck` Module"},{"location":"recheck/#documentation-for-recheck-module","text":"Module container Checker Class. The CheckerClass takes a torrentfile and tha path to it's contents. It will then iterate through every file and directory contained and compare their data to values contained within the torrent file. Completion percentages will be printed to screen for each file and at the end for the torrentfile as a whole.","title":"Documentation for Recheck Module"},{"location":"recheck/#torrentfile.recheck.Checker","text":"Check a given file or directory to see if it matches a torrentfile. Public constructor for Checker class instance. Parameters: Name Type Description Default metafile `str` Path to \".torrent\" file. required location `str` Path where the content is located in filesystem. required Examples: metafile = \"/path/to/torrentfile/content_file_or_dir.torrent\" location = \"/path/to/location\" os.path.exists(\"/path/to/location/content_file_or_dir\") Out: True checker = Checker(metafile, location)","title":"Checker"},{"location":"recheck/#torrentfile.recheck.Checker.result","text":"Generate result percentage and store for future calls.","title":"result"},{"location":"recheck/#torrentfile.recheck.Checker.__init__","text":"Validate data against hashes contained in .torrent file. Parameters: Name Type Description Default metafile `str` path to .torrent file required path `str` path to content or contents parent directory. required Source code in torrentfile\\recheck.py def __init__ ( self , metafile , path ): \"\"\"Validate data against hashes contained in .torrent file. Args: metafile (`str`): path to .torrent file path (`str`): path to content or contents parent directory. \"\"\" self . _result = None self . meta_version = None self . metafile = metafile self . last_log = None self . log_msg ( \"Checking: %s , %s \" , metafile , path ) self . info = self . parse_metafile () self . name = self . info [ \"name\" ] self . piece_length = self . info [ \"piece length\" ] self . root = self . find_root ( path ) self . total = 0 self . paths = [] self . fileinfo = {} self . check_paths ()","title":"__init__()"},{"location":"recheck/#torrentfile.recheck.Checker.check_paths","text":"Gather all file paths described in the torrent file. Source code in torrentfile\\recheck.py def check_paths ( self ): \"\"\"Gather all file paths described in the torrent file.\"\"\" if os . path . isfile ( self . root ): self . log_msg ( \" %s points to a single file\" , self . root ) self . paths . append ( self . root ) if self . meta_version == 1 : self . fileinfo [ self . root ] = { \"length\" : self . info [ \"length\" ]} self . total = self . info [ \"length\" ] self . pieces = split_pieces ( self . info [ \"pieces\" ], SHA1 ) else : info = self . info [ \"file tree\" ][ self . name ][ \"\" ] info [ \"partial\" ] = self . name self . total = info [ \"length\" ] if self . total > self . piece_length : layers = self . info [ \"piece layers\" ][ info [ \"pieces root\" ]] info [ \"layer hashes\" ] = split_pieces ( layers , SHA256 ) self . fileinfo [ self . root ] = info return # Otherwise Content is more than 1 file. self . log_msg ( \" %s points to a directory\" , self . root ) if self . meta_version == 1 : for path in self . info [ \"files\" ]: self . total += path [ \"length\" ] rlpath = os . path . join ( * path [ \"path\" ]) full = os . path . join ( self . root , rlpath ) self . log_msg ( \"Including file path: %s \" , rlpath ) self . fileinfo [ full ] = { \"length\" : path [ \"length\" ]} self . paths . append ( full ) # Split pieces into individual hash digests. self . pieces = split_pieces ( self . info [ \"pieces\" ], SHA1 ) return self . walk_file_tree ( self . info [ \"file tree\" ], [])","title":"check_paths()"},{"location":"recheck/#torrentfile.recheck.Checker.find_root","text":"Check path for torrent content. The path can be a relative or absolute filesystem path. In the case where the content is a single file, the path may point directly to the the file, or it may point to the parent directory. If content points to a directory. The directory will be checked to see if it matches the torrent's name, if not the directories contents will be searched. The returned value will be the absolute path that matches the torrent's name. Returns: Type Description `str` root path to content Source code in torrentfile\\recheck.py def find_root ( self , path ): \"\"\"Check path for torrent content. The path can be a relative or absolute filesystem path. In the case where the content is a single file, the path may point directly to the the file, or it may point to the parent directory. If content points to a directory. The directory will be checked to see if it matches the torrent's name, if not the directories contents will be searched. The returned value will be the absolute path that matches the torrent's name. Returns: `str`: root path to content \"\"\" if not os . path . exists ( path ): self . log_msg ( \"Could not locate torrent content %s .\" , path ) raise FileNotFoundError ( path ) root = os . path . abspath ( path ) base = os . path . basename ( root ) if base == self . name : self . log_msg ( \"Content found: %s .\" , root ) return root self . log_msg ( \"Searching for torrent root in %s \" , root ) for name in os . listdir ( root ): if name == self . name : root = os . path . join ( root , name ) self . log_msg ( \"Content Found: %s \" , root ) return root self . log_msg ( \"Could not locate torrent content in: %s \" , root ) raise FileNotFoundError ( root )","title":"find_root()"},{"location":"recheck/#torrentfile.recheck.Checker.iter_hashes","text":"Produce results of comparing torrent contents piece by piece. Returns: Type Description chunck (`bytes`) hash of data found on disk piece ( bytes ): hash of data when complete and correct path ( str ): path to file being hashed size ( int ): length of bytes hashed for piece Source code in torrentfile\\recheck.py def iter_hashes ( self ): \"\"\"Produce results of comparing torrent contents piece by piece. Returns: chunck (`bytes`): hash of data found on disk piece (`bytes`): hash of data when complete and correct path (`str`): path to file being hashed size (`int`): length of bytes hashed for piece \"\"\" matched = consumed = 0 if self . meta_version == 1 : checker = FeedChecker args = ( self . paths , self . piece_length , self . fileinfo , self . pieces ) else : checker = HashChecker hasher = HasherV2 if self . meta_version == 2 else HasherHybrid args = ( self . paths , self . piece_length , self . fileinfo , hasher ) for chunk , piece , path , size in checker ( * args ): consumed += size msg = \"Match %s : %s %s \" humansize = humanize_bytes ( size ) if chunk == piece : matched += size logging . debug ( msg , \"Success\" , path , humansize ) else : logging . debug ( msg , \"Fail\" , path , humansize ) yield chunk , piece , path , size total_consumed = str ( int ( consumed / self . total * 100 )) percent_matched = str ( int ( matched / consumed * 100 )) self . log_msg ( \"Processed: %s%% , Matched: %s%% \" , total_consumed , percent_matched , ) if consumed : self . log_msg ( \"Re-Check Complete: \\n %s%% of %s found at %s \" , percent_matched , self . metafile , self . root , ) self . _result = percent_matched else : # pragma: no cover self . log_msg ( \"Re-Check Complete: \\n 0 %% of %s found at %s \" , self . metafile , self . root , ) self . _result = \"0\"","title":"iter_hashes()"},{"location":"recheck/#torrentfile.recheck.Checker.log_msg","text":"Log message msg to logger and send msg to callback hook. Parameters: Name Type Description Default `*args` `Iterable`[`str`] formatting args for log message required level `int`, default=`logging.INFO`) Log level for this message 20 Source code in torrentfile\\recheck.py def log_msg ( self , * args , level = logging . INFO ): \"\"\"Log message `msg` to logger and send `msg` to callback hook. Args: `*args` (`Iterable`[`str`]): formatting args for log message level (`int`, default=`logging.INFO`) : Log level for this message \"\"\" message = args [ 0 ] if len ( args ) >= 3 : message = message % tuple ( args [ 1 :]) elif len ( args ) == 2 : message = message % args [ 1 ] # Repeat log messages should be ignored. if message != self . last_log : self . last_log = message logging . log ( level , message ) if self . _hook and level == logging . INFO : self . _hook ( message )","title":"log_msg()"},{"location":"recheck/#torrentfile.recheck.Checker.parse_metafile","text":"Flatten Meta dictionary of torrent file. Returns: Type Description `dict` flattened meta dictionary. Source code in torrentfile\\recheck.py def parse_metafile ( self ): \"\"\"Flatten Meta dictionary of torrent file. Returns: `dict`: flattened meta dictionary. \"\"\" if not os . path . exists ( self . metafile ): self . log_msg ( \"File %s could not be found.\" , self . metafile ) raise FileNotFoundError ( self . metafile ) info = {} has_pieces = has_meta_version = False for k , v in pyben . load ( self . metafile ) . items (): if k == \"info\" : for key , val in v . items (): info [ key ] = val if key == \"pieces\" : has_pieces = True if key == \"meta version\" : has_meta_version = True else : info [ k ] = v if has_meta_version and has_pieces : self . meta_version = 3 elif has_meta_version : self . meta_version = 2 else : self . meta_version = 1 self . log_msg ( \"Detected Meta Version %s .\" , str ( self . meta_version )) return info","title":"parse_metafile()"},{"location":"recheck/#torrentfile.recheck.Checker.register_callback","text":"Register hooks from 3rd party programs to access generated info. Parameters: Name Type Description Default hook `function` callback function for the logging feature. required Source code in torrentfile\\recheck.py @classmethod def register_callback ( cls , hook ): \"\"\"Register hooks from 3rd party programs to access generated info. Args: hook (`function`): callback function for the logging feature. \"\"\" cls . _hook = hook","title":"register_callback()"},{"location":"recheck/#torrentfile.recheck.Checker.walk_file_tree","text":"Traverse File Tree dictionary to get file details. Extract full pathnames, length, root hash, and layer hashes for each file included in the .torrent's file tree. Parameters: Name Type Description Default tree `dict` File Tree dict extracted from torrent file. required partials `list` list of intermediate pathnames. required Source code in torrentfile\\recheck.py def walk_file_tree ( self , tree , partials ): \"\"\"Traverse File Tree dictionary to get file details. Extract full pathnames, length, root hash, and layer hashes for each file included in the .torrent's file tree. Args: tree (`dict`): File Tree dict extracted from torrent file. partials (`list`): list of intermediate pathnames. \"\"\" for key , val in tree . items (): # Empty string means the tree's leaf is value if \"\" in val : path = os . path . join ( self . root , * partials , key ) info = self . fileinfo [ path ] = val [ \"\" ] info [ \"partial\" ] = key size = val [ \"\" ][ \"length\" ] # get layer hashes for this file if size > self . piece_length : root = val [ \"\" ][ \"pieces root\" ] layer_hashes = self . info [ \"piece layers\" ][ root ] info [ \"layer hashes\" ] = split_pieces ( layer_hashes , SHA256 ) self . paths . append ( path ) self . total += size self . log_msg ( \"Including: path - %s , length - %s \" , path , humanize_bytes ( size ), ) else : self . walk_file_tree ( val , partials + [ key ])","title":"walk_file_tree()"},{"location":"recheck/#torrentfile.recheck.FeedChecker","text":"Validates torrent content. Seemlesly validate torrent file contents by comparing hashes in metafile against data on disk. Parameters: Name Type Description Default paths `list` List of stirngs indicating file paths. required piece_length `int` Size of data blocks to split the data into. required total `int` Sum total in bytes of all files in file list. required fileinfo `dict` Info and meta dictionary from .torrent file. required","title":"FeedChecker"},{"location":"recheck/#torrentfile.recheck.FeedChecker.current_length","text":"Length of current file contents in bytes.","title":"current_length"},{"location":"recheck/#torrentfile.recheck.FeedChecker.__init__","text":"Generate hashes of piece length data from filelist contents. Source code in torrentfile\\recheck.py def __init__ ( self , paths , piece_length , fileinfo , pieces ): \"\"\"Generate hashes of piece length data from filelist contents.\"\"\" self . piece_length = piece_length self . paths = paths self . pieces = pieces self . fileinfo = fileinfo self . piece_map = {} self . index = 0 self . piece_count = 0 self . itor = None","title":"__init__()"},{"location":"recheck/#torrentfile.recheck.FeedChecker.__iter__","text":"Assign iterator and return self. Source code in torrentfile\\recheck.py def __iter__ ( self ): \"\"\"Assign iterator and return self.\"\"\" self . itor = self . iter_pieces () return self","title":"__iter__()"},{"location":"recheck/#torrentfile.recheck.FeedChecker.__next__","text":"Yield back result of comparison. Source code in torrentfile\\recheck.py def __next__ ( self ): \"\"\"Yield back result of comparison.\"\"\" partial = next ( self . itor ) chunck = sha1 ( partial ) . digest () # nosec try : piece = self . pieces [ self . piece_count ] except IndexError : raise StopIteration # pragma: no cover path = self . paths [ self . index ] self . piece_count += 1 return chunck , piece , path , len ( partial )","title":"__next__()"},{"location":"recheck/#torrentfile.recheck.FeedChecker.extract","text":"Split file paths contents into blocks of data for hash pieces. Parameters: Name Type Description Default path `str` path to content. required partial `bytes` any remaining content from last file. required Yields partial ( bytes ): Hash digest for block of .torrent contents. Source code in torrentfile\\recheck.py def extract ( self , path , partial ): \"\"\"Split file paths contents into blocks of data for hash pieces. Args: path (`str`): path to content. partial (`bytes`): any remaining content from last file. Yields: partial (`bytes`): Hash digest for block of .torrent contents. \"\"\" read = 0 size = os . path . getsize ( path ) length = self . fileinfo [ path ][ \"length\" ] with open ( path , \"rb\" ) as current : while True : bitlength = self . piece_length - len ( partial ) part = bytearray ( bitlength ) amount = current . readinto ( part ) read += amount partial . extend ( part [: amount ]) if amount < bitlength : if size == read == length : yield partial break yield partial partial = bytearray ( 0 ) while length - size > 0 : left = self . piece_length - len ( partial ) if length - size > left : padding = bytearray ( left ) size += left partial . extend ( padding ) yield partial partial = bytearray ( 0 ) else : partial . extend ( bytearray ( length - size )) size += length - size yield partial","title":"extract()"},{"location":"recheck/#torrentfile.recheck.FeedChecker.iter_pieces","text":"Iterate through, and hash pieces of torrent contents. Yields piece ( bytes ): hash digest for block of torrent data. Source code in torrentfile\\recheck.py def iter_pieces ( self ): \"\"\"Iterate through, and hash pieces of torrent contents. Yields: piece (`bytes`): hash digest for block of torrent data. \"\"\" partial = bytearray () for i , path in enumerate ( self . paths ): self . index = i if os . path . exists ( path ): for piece in self . extract ( path , partial ): if len ( piece ) == self . piece_length : yield piece partial = bytearray () elif i + 1 == len ( self . paths ): yield piece else : partial = piece else : for blank in self . _gen_blanks ( partial ): if len ( blank ) == self . piece_length : yield blank partial = bytearray () else : partial = blank","title":"iter_pieces()"},{"location":"recheck/#torrentfile.recheck.HashChecker","text":"Construct the HybridChecker. Verify that root hashes of content files match the .torrent files. Parameters: Name Type Description Default paths `list` List of files. required piece_length `int` Size of chuncks to split the data into. required fileinfo `dict` Info from .torrent file being checked. required","title":"HashChecker"},{"location":"recheck/#torrentfile.recheck.HashChecker.__init__","text":"Construct a HybridChecker instance. Source code in torrentfile\\recheck.py def __init__ ( self , paths , piece_length , fileinfo , hasher ): \"\"\"Construct a HybridChecker instance.\"\"\" self . paths = paths self . hasher = hasher self . piece_length = piece_length self . fileinfo = fileinfo self . itor = None logging . debug ( \"Starting Hash Checker. piece length: %s \" , humanize_bytes ( self . piece_length ), )","title":"__init__()"},{"location":"recheck/#torrentfile.recheck.HashChecker.__iter__","text":"Assign iterator and return self. Source code in torrentfile\\recheck.py def __iter__ ( self ): \"\"\"Assign iterator and return self.\"\"\" self . itor = self . iter_paths () return self","title":"__iter__()"},{"location":"recheck/#torrentfile.recheck.HashChecker.__next__","text":"Provide the result of comparison. Source code in torrentfile\\recheck.py def __next__ ( self ): \"\"\"Provide the result of comparison.\"\"\" try : value = next ( self . itor ) return value except StopIteration as stopiter : raise StopIteration () from stopiter","title":"__next__()"},{"location":"recheck/#torrentfile.recheck.HashChecker.iter_paths","text":"Iterate through and compare root file hashes to .torrent file. Parameters: Name Type Description Default hasher class The class user to caluclate root hash. required Yields results ( tuple ): The size of the file and result of match. Source code in torrentfile\\recheck.py def iter_paths ( self ): \"\"\"Iterate through and compare root file hashes to .torrent file. Args: hasher (class): The class user to caluclate root hash. Yields: results (`tuple`): The size of the file and result of match. \"\"\" for path in self . paths : info = self . fileinfo [ path ] length = info [ \"length\" ] logging . debug ( \" %s length: %s \" , path , str ( length )) roothash = info [ \"pieces root\" ] logging . debug ( \" %s root hash %s \" , path , str ( roothash )) if not os . path . exists ( path ): if \"layer hashes\" in info and info [ \"layer hashes\" ]: pieces = info [ \"layer hashes\" ] else : pieces = [ roothash ] for i , piece in enumerate ( pieces ): if len ( pieces ) == 1 : size = length elif i < len ( pieces ) - 1 : size = self . piece_length else : size = length - (( len ( pieces ) - 1 ) * self . piece_length ) logging . debug ( \"Yielding: %s %s %s %s \" , str ( bytes ( SHA256 )), str ( piece ), path , str ( size ), ) yield bytes ( SHA256 ), piece , path , size continue hashed = self . hasher ( path , self . piece_length ) if \"layer hashes\" in info : hash_pieces = split_pieces ( hashed . piece_layer , SHA256 ) info_pieces = info [ \"layer hashes\" ] else : hash_pieces = [ hashed . root ] info_pieces = [ info [ \"pieces root\" ]] diff = len ( info_pieces ) - len ( hash_pieces ) if diff > 0 : hash_pieces += [ bytes ( SHA256 )] * diff num_pieces = len ( hash_pieces ) size = self . piece_length for chunk , piece in zip ( hash_pieces , info_pieces ): if num_pieces == 1 : size = length - (( len ( hash_pieces ) - 1 ) * size ) logging . debug ( \"Yielding: %s , %s , %s , %s \" , str ( chunk ), str ( piece ), str ( path ), str ( size ), ) yield chunk , piece , path , size num_pieces -= 1","title":"iter_paths()"},{"location":"recheck/#torrentfile.recheck.split_pieces","text":"Split bytes into 20 piece chuncks for sha1 digest. Parameters: Name Type Description Default pieces `bytes` Initial data. required Returns: Type Description lst (`list`) Pieces broken into groups of 20 bytes. Source code in torrentfile\\recheck.py def split_pieces ( pieces , hash_size ): \"\"\"Split bytes into 20 piece chuncks for sha1 digest. Args: pieces (`bytes`): Initial data. Returns: lst (`list`): Pieces broken into groups of 20 bytes. \"\"\" lst = [] start = 0 while start < len ( pieces ): end = start + hash_size lst . append ( pieces [ start : end ]) start += hash_size return lst module torrentfile. recheck Module container Checker Class. The CheckerClass takes a torrentfile and tha path to it's contents. It will then iterate through every file and directory contained and compare their data to values contained within the torrent file. Completion percentages will be printed to screen for each file and at the end for the torrentfile as a whole. Classes Checker \u2014 Check a given file or directory to see if it matches a torrentfile. FeedChecker \u2014 Validates torrent content. HashChecker \u2014 Construct the HybridChecker. Functions split_pieces ( pieces , hash_size ) (lst (`list`)) \u2014 Split bytes into 20 piece chuncks for sha1 digest.","title":"split_pieces()"},{"location":"torrent/","text":"Documentation for Torrent Module Base and Subclasses for bittorrent meta files. This module metafile2 contains classes and functions related to constructing .torrent files using Bittorrent v2 Protocol Classes TorrentFile : construct .torrent file. TorrentFileV2 : construct .torrent v2 files using provided data. MetaFile base class for all MetaFile classes. Constants BLOCK_SIZE ( int ): size of leaf hashes for merkle tree. HASH_SIZE ( int ): Length of a sha256 hash. Notes Implementation details for Bittorrent Protocol v2. Metainfo files (also known as .torrent files) are bencoded dictionaries with the following keys: \"announce\": The URL of the tracker. \"info\": This maps to a dictionary, with keys described below. \"name\": A display name for the torrent. It is purely advisory. \"piece length\": The number of bytes that each logical piece in the peer protocol refers to. I.e. it sets the granularity of piece, request, bitfield and have messages. It must be a power of two and at least 6KiB. \"meta version\": An integer value, set to 2 to indicate compatibility with the current revision of this specification. Version 1 is not assigned to avoid confusion with BEP3. Future revisions will only increment this issue to indicate an incompatible change has been made, for example that hash algorithms were changed due to newly discovered vulnerabilities. Lementations must check this field first and indicate that a torrent is of a newer version than they can handle before performing other idations which may result in more general messages about invalid files. Files are mapped into this piece address space so that each non-empty \"file tree\": A tree of dictionaries where dictionary keys represent UTF-8 encoded path elements. Entries with zero-length keys describe the properties of the composed path at that point. 'UTF-8 encoded' in this context only means that if the native encoding is known at creation time it must be converted to UTF-8. Keys may contain invalid UTF-8 sequences or characters and names that are reserved on specific filesystems. Implementations must be prepared to sanitize them. On most platforms path components exactly matching '.' and '..' must be sanitized since they could lead to directory traversal attacks and conflicting path descriptions. On platforms that require valid UTF-8 path components this sanitizing step must happen after normalizing overlong UTF-8 encodings. File is aligned to a piece boundary and occurs in the same order as in the file tree. The last piece of each file may be shorter than the specified piece length, resulting in an alignment gap. \"length\": Length of the file in bytes. Presence of this field indicates that the dictionary describes a file, not a directory. Which means it must not have any sibling entries. \"pieces root\": For non-empty files this is the the root hash of a merkle tree with a branching factor of 2, constructed from 16KiB blocks of the file. The last block may be shorter than 16KiB. The remaining leaf hashes beyond the end of the file required to construct upper layers of the merkle tree are set to zero. As of meta version 2 SHA2-256 is used as digest function for the merkle tree. The hash is stored in its binary form, not as human-readable string. \"piece layers\": A dictionary of strings. For each file in the file tree that is larger than the piece size it contains one string value. The keys are the merkle roots while the values consist of concatenated hashes of one layer within that merkle tree. The layer is chosen so that one hash covers piece length bytes. For example if the piece size is 16KiB then the leaf hashes are used. If a piece size of 128KiB is used then 3rd layer up from the leaf hashes is used. Layer hashes which exclusively cover data beyond the end of file, i.e. are only needed to balance the tree, are omitted. All hashes are stored in their binary format. A torrent is not valid if this field is absent, the contained hashes do not match the merkle roots or are not from the correct layer. The file tree root dictionary itself must not be a file, i.e. it must not contain a zero-length key with a dictionary containing a length key. From Bittorrent.org Documentation pages. Metainfo files (also known as .torrent files) are bencoded dictionaries with the following keys: announce The URL of the tracker. info This maps to a dictionary, with keys described below. All strings in a .torrent file that contains text must be UTF-8 encoded. info dictionary The name key maps to a UTF-8 encoded string which is the suggested name to save the file (or directory) as. It is purely advisory. piece length maps to the number of bytes in each piece the file is split into. For the purposes of transfer, files are split into fixed-size pieces which are all the same length except for possibly the last one which may be truncated. piece length is almost always a power of two, most commonly 2 18 = 256 K (BitTorrent prior to version 3.2 uses 2 20 = 1 M as default). pieces maps to a string whose length is a multiple of 20. It is to be subdivided into strings of length 20, each of which is the SHA1 hash of the piece at the corresponding index. There is also a key length or a key files , but not both or neither. If length is present then the download represents a single file, otherwise it represents a set of files which go in a directory structure. In the single file case, length maps to the length of the file in bytes. For the purposes of the other keys, the multi-file case is treated as only having a single file by concatenating the files in the order they appear in the files list. The files list is the value files maps to, and is a list of dictionaries containing the following keys: length - The length of the file, in bytes. path - A list of UTF-8 encoded strings corresponding to subdirectory names, the last of which is the actual file name (a zero length list is an error case). In the single file case, the name key is the name of a file, in the muliple file case, it's the name of a directory. MetaFile Base Class for all TorrentFile classes. Parameters: Name Type Description Default path `str` target path to torrent content. required announce `str` One or more tracker URL's. required comment `str` A comment. required piece_length `int` Size of torrent pieces. required private `bool` For private trackers? required outfile `str` target path to write .torrent file. required source `str` Private tracker source. required __init__ ( self , path = None , announce = None , private = False , source = None , piece_length = None , comment = None , outfile = None ) special Construct MetaFile superclass and assign local attributes. Source code in torrentfile\\torrent.py def __init__ ( self , path = None , announce = None , private = False , source = None , piece_length = None , comment = None , outfile = None , ): \"\"\"Construct MetaFile superclass and assign local attributes.\"\"\" if not path : raise utils . MissingPathError # base path to torrent content. self . path = path # Format piece_length attribute. if piece_length : self . piece_length = utils . normalize_piece_length ( piece_length ) else : self . piece_length = utils . path_piece_length ( self . path ) # Assign announce URL to empty string if none provided. if not announce : self . announce = \"\" self . announce_list = [[ \"\" ]] # Most torrent clients have editting trackers as a feature. elif isinstance ( announce , str ): self . announce = announce self . announce_list = [[ announce ]] elif isinstance ( announce , Sequence ): self . announce = announce [ 0 ] self . announce_list = [[ i ] for i in announce ] if private : self . private = 1 else : self . private = private self . source = source self . comment = comment self . outfile = outfile self . meta = { \"announce\" : self . announce , \"announce list\" : self . announce_list , \"created by\" : f \"TorrentFile:v { version } \" , \"creation date\" : int ( datetime . timestamp ( datetime . now ())), \"info\" : {}, } if self . comment : self . meta [ \"info\" ][ \"comment\" ] = self . comment if self . private : self . meta [ \"info\" ][ \"private\" ] = self . private if self . source : self . meta [ \"info\" ][ \"source\" ] = self . source self . meta [ \"info\" ][ \"name\" ] = os . path . basename ( self . path ) self . meta [ \"info\" ][ \"piece length\" ] = self . piece_length assemble ( self ) Overload in subclasses. Source code in torrentfile\\torrent.py def assemble ( self ): \"\"\"Overload in subclasses. Raises: NotImplementedError (`Exception`) \"\"\" raise NotImplementedError sort_meta ( self ) Sort the info and meta dictionaries. Source code in torrentfile\\torrent.py def sort_meta ( self ): \"\"\"Sort the info and meta dictionaries.\"\"\" meta = self . meta meta [ \"info\" ] = dict ( sorted ( list ( meta [ \"info\" ] . items ()))) meta = dict ( sorted ( list ( meta . items ()))) return meta write ( self , outfile = None ) Write meta information to .torrent file. Parameters: Name Type Description Default outfile `str`, default=None Destination path for .torrent file. None Returns: Type Description outfile (`str`) Where the .torrent file was writen. meta ( dict ): .torrent meta information. Source code in torrentfile\\torrent.py def write ( self , outfile = None ): \"\"\"Write meta information to .torrent file. Args: outfile (`str`, default=None): Destination path for .torrent file. Returns: outfile (`str`): Where the .torrent file was writen. meta (`dict`): .torrent meta information. \"\"\" if outfile is not None : self . outfile = outfile if self . outfile is None : self . outfile = str ( self . path ) + \".torrent\" self . meta = self . sort_meta () pyben . dump ( self . meta , self . outfile ) return self . outfile , self . meta TorrentFile ( MetaFile ) Class for creating Bittorrent meta files. Construct Torrentfile class instance object. Parameters: Name Type Description Default path(`str`) Path to torrent file or directory. required piece_length(`int`) Size of each piece of torrent data. required announce(`str` or `list` One or more tracker URL's. required private(`int`) 1 if private torrent else 0. required source(`str`) Source tracker. required comment(`str`) Comment string. required outfile(`str`) Path to write metfile to. required __init__ ( self , ** kwargs ) special Construct TorrentFile instance with given keyword args. Parameters: Name Type Description Default kwargs `dict` dictionary of keyword args passed to superclass. {} Source code in torrentfile\\torrent.py def __init__ ( self , ** kwargs ): \"\"\"Construct TorrentFile instance with given keyword args. Args: kwargs (`dict`): dictionary of keyword args passed to superclass. \"\"\" super () . __init__ ( ** kwargs ) logging . debug ( \"Making Bittorrent V1 meta file.\" ) self . assemble () assemble ( self ) Assemble components of torrent metafile. Returns: Type Description `dict` metadata dictionary for torrent file Source code in torrentfile\\torrent.py def assemble ( self ): \"\"\"Assemble components of torrent metafile. Returns: `dict`: metadata dictionary for torrent file \"\"\" info = self . meta [ \"info\" ] size , filelist = utils . filelist_total ( self . path ) if os . path . isfile ( self . path ): info [ \"length\" ] = size else : info [ \"files\" ] = [ { \"length\" : os . path . getsize ( path ), \"path\" : os . path . relpath ( path , self . path ) . split ( os . sep ), } for path in filelist ] pieces = bytearray () feeder = Hasher ( filelist , self . piece_length ) for piece in feeder : pieces . extend ( piece ) info [ \"pieces\" ] = pieces TorrentFileHybrid ( MetaFile ) Construct the Hybrid torrent meta file with provided parameters. Parameters: Name Type Description Default path `str` path to torrentfile target. required announce `str` or `list` one or more tracker URL's. required comment `str` Some comment. required source `str` Used for private trackers. required outfile `str` target path to write output. required private `bool` Used for private trackers. required piece_length `int` torrentfile data piece length. required __init__ ( self , ** kwargs ) special Create Bittorrent v1 v2 hybrid metafiles. Source code in torrentfile\\torrent.py def __init__ ( self , ** kwargs ): \"\"\"Create Bittorrent v1 v2 hybrid metafiles.\"\"\" super () . __init__ ( ** kwargs ) logging . debug ( \"Creating Hybrid torrent file.\" ) self . name = os . path . basename ( self . path ) self . hashes = [] self . piece_layers = {} self . pieces = [] self . files = [] self . assemble () assemble ( self ) Assemble the parts of the torrentfile into meta dictionary. Source code in torrentfile\\torrent.py def assemble ( self ): \"\"\"Assemble the parts of the torrentfile into meta dictionary.\"\"\" info = self . meta [ \"info\" ] info [ \"meta version\" ] = 2 if os . path . isfile ( self . path ): info [ \"file tree\" ] = { self . name : self . _traverse ( self . path )} info [ \"length\" ] = os . path . getsize ( self . path ) else : info [ \"file tree\" ] = self . _traverse ( self . path ) info [ \"files\" ] = self . files info [ \"pieces\" ] = b \"\" . join ( self . pieces ) self . meta [ \"piece layers\" ] = self . piece_layers return info TorrentFileV2 ( MetaFile ) Class for creating Bittorrent meta v2 files. Parameters: Name Type Description Default path `str` Path to torrent file or directory. required piece_length `int` Size of each piece of torrent data. required announce `str` or `list` one or more tracker URL's. required private `int` 1 if private torrent else 0. required source `str` Source tracker. required comment `str` Comment string. required outfile `str` Path to write metfile to. required __init__ ( self , ** kwargs ) special Construct TorrentFileV2 Class instance from given parameters. Parameters: Name Type Description Default kwargs `dict` keywword arguments to pass to superclass. {} Source code in torrentfile\\torrent.py def __init__ ( self , ** kwargs ): \"\"\"Construct `TorrentFileV2` Class instance from given parameters. Args: kwargs (`dict`): keywword arguments to pass to superclass. \"\"\" super () . __init__ ( ** kwargs ) logging . debug ( \"Create .torrent v2 file.\" ) self . piece_layers = {} self . hashes = [] self . assemble () assemble ( self ) Assemble then return the meta dictionary for encoding. Returns: Type Description meta (`dict`) Metainformation about the torrent. Source code in torrentfile\\torrent.py def assemble ( self ): \"\"\"Assemble then return the meta dictionary for encoding. Returns: meta (`dict`): Metainformation about the torrent. \"\"\" info = self . meta [ \"info\" ] if os . path . isfile ( self . path ): info [ \"file tree\" ] = { info [ \"name\" ]: self . _traverse ( self . path )} info [ \"length\" ] = os . path . getsize ( self . path ) else : info [ \"file tree\" ] = self . _traverse ( self . path ) info [ \"meta version\" ] = 2 self . meta [ \"piece layers\" ] = self . piece_layers module torrentfile. torrent Base and Subclasses for bittorrent meta files. This module metafile2 contains classes and functions related to constructing .torrent files using Bittorrent v2 Protocol Classes: TorrentFile : construct .torrent file. TorrentFileV2 : construct .torrent v2 files using provided data. MetaFile base class for all MetaFile classes. Constants: BLOCK_SIZE ( int ): size of leaf hashes for merkle tree. HASH_SIZE ( int ): Length of a sha256 hash. Notes Implementation details for Bittorrent Protocol v2. Metainfo files (also known as .torrent files) are bencoded dictionaries with the following keys: \"announce\": The URL of the tracker. \"info\": This maps to a dictionary, with keys described below. \"name\": A display name for the torrent. It is purely advisory. \"piece length\": The number of bytes that each logical piece in the peer protocol refers to. I.e. it sets the granularity of piece, request, bitfield and have messages. It must be a power of two and at least 6KiB. \"meta version\": An integer value, set to 2 to indicate compatibility with the current revision of this specification. Version 1 is not assigned to avoid confusion with BEP3. Future revisions will only increment this issue to indicate an incompatible change has been made, for example that hash algorithms were changed due to newly discovered vulnerabilities. Lementations must check this field first and indicate that a torrent is of a newer version than they can handle before performing other idations which may result in more general messages about invalid files. Files are mapped into this piece address space so that each non-empty \"file tree\": A tree of dictionaries where dictionary keys represent UTF-8 encoded path elements. Entries with zero-length keys describe the properties of the composed path at that point. 'UTF-8 encoded' in this context only means that if the native encoding is known at creation time it must be converted to UTF-8. Keys may contain invalid UTF-8 sequences or characters and names that are reserved on specific filesystems. Implementations must be prepared to sanitize them. On most platforms path components exactly matching '.' and '..' must be sanitized since they could lead to directory traversal attacks and conflicting path descriptions. On platforms that require valid UTF-8 path components this sanitizing step must happen after normalizing overlong UTF-8 encodings. File is aligned to a piece boundary and occurs in the same order as in the file tree. The last piece of each file may be shorter than the specified piece length, resulting in an alignment gap. \"length\": Length of the file in bytes. Presence of this field indicates that the dictionary describes a file, not a directory. Which means it must not have any sibling entries. \"pieces root\": For non-empty files this is the the root hash of a merkle tree with a branching factor of 2, constructed from 16KiB blocks of the file. The last block may be shorter than 16KiB. The remaining leaf hashes beyond the end of the file required to construct upper layers of the merkle tree are set to zero. As of meta version 2 SHA2-256 is used as digest function for the merkle tree. The hash is stored in its binary form, not as human-readable string. \"piece layers\": A dictionary of strings. For each file in the file tree that is larger than the piece size it contains one string value. The keys are the merkle roots while the values consist of concatenated hashes of one layer within that merkle tree. The layer is chosen so that one hash covers piece length bytes. For example if the piece size is 16KiB then the leaf hashes are used. If a piece size of 128KiB is used then 3rd layer up from the leaf hashes is used. Layer hashes which exclusively cover data beyond the end of file, i.e. are only needed to balance the tree, are omitted. All hashes are stored in their binary format. A torrent is not valid if this field is absent, the contained hashes do not match the merkle roots or are not from the correct layer. The file tree root dictionary itself must not be a file, i.e. it must not contain a zero-length key with a dictionary containing a length key. From Bittorrent.org Documentation pages. Metainfo files (also known as .torrent files) are bencoded dictionaries with the following keys: announce The URL of the tracker. info This maps to a dictionary, with keys described below. All strings in a .torrent file that contains text must be UTF-8 encoded. info dictionary The name key maps to a UTF-8 encoded string which is the suggested name to save the file (or directory) as. It is purely advisory. piece length maps to the number of bytes in each piece the file is split into. For the purposes of transfer, files are split into fixed-size pieces which are all the same length except for possibly the last one which may be truncated. piece length is almost always a power of two, most commonly 2 18 = 256 K (BitTorrent prior to version 3.2 uses 2 20 = 1 M as default). pieces maps to a string whose length is a multiple of 20. It is to be subdivided into strings of length 20, each of which is the SHA1 hash of the piece at the corresponding index. There is also a key length or a key files , but not both or neither. If length is present then the download represents a single file, otherwise it represents a set of files which go in a directory structure. In the single file case, length maps to the length of the file in bytes. For the purposes of the other keys, the multi-file case is treated as only having a single file by concatenating the files in the order they appear in the files list. The files list is the value files maps to, and is a list of dictionaries containing the following keys: length - The length of the file, in bytes. path - A list of UTF-8 encoded strings corresponding to subdirectory names, the last of which is the actual file name (a zero length list is an error case). In the single file case, the name key is the name of a file, in the muliple file case, it's the name of a directory. Classes MetaFile \u2014 Base Class for all TorrentFile classes. TorrentFile \u2014 Class for creating Bittorrent meta files. TorrentFileV2 \u2014 Class for creating Bittorrent meta v2 files. TorrentFileHybrid \u2014 Construct the Hybrid torrent meta file with provided parameters.","title":"Documentation for `Torrent` Module"},{"location":"torrent/#documentation-for-torrent-module","text":"Base and Subclasses for bittorrent meta files. This module metafile2 contains classes and functions related to constructing .torrent files using Bittorrent v2 Protocol Classes TorrentFile : construct .torrent file. TorrentFileV2 : construct .torrent v2 files using provided data. MetaFile base class for all MetaFile classes. Constants BLOCK_SIZE ( int ): size of leaf hashes for merkle tree. HASH_SIZE ( int ): Length of a sha256 hash.","title":"Documentation for Torrent Module"},{"location":"torrent/#torrentfile.torrent--notes","text":"Implementation details for Bittorrent Protocol v2. Metainfo files (also known as .torrent files) are bencoded dictionaries with the following keys: \"announce\": The URL of the tracker. \"info\": This maps to a dictionary, with keys described below. \"name\": A display name for the torrent. It is purely advisory. \"piece length\": The number of bytes that each logical piece in the peer protocol refers to. I.e. it sets the granularity of piece, request, bitfield and have messages. It must be a power of two and at least 6KiB. \"meta version\": An integer value, set to 2 to indicate compatibility with the current revision of this specification. Version 1 is not assigned to avoid confusion with BEP3. Future revisions will only increment this issue to indicate an incompatible change has been made, for example that hash algorithms were changed due to newly discovered vulnerabilities. Lementations must check this field first and indicate that a torrent is of a newer version than they can handle before performing other idations which may result in more general messages about invalid files. Files are mapped into this piece address space so that each non-empty \"file tree\": A tree of dictionaries where dictionary keys represent UTF-8 encoded path elements. Entries with zero-length keys describe the properties of the composed path at that point. 'UTF-8 encoded' in this context only means that if the native encoding is known at creation time it must be converted to UTF-8. Keys may contain invalid UTF-8 sequences or characters and names that are reserved on specific filesystems. Implementations must be prepared to sanitize them. On most platforms path components exactly matching '.' and '..' must be sanitized since they could lead to directory traversal attacks and conflicting path descriptions. On platforms that require valid UTF-8 path components this sanitizing step must happen after normalizing overlong UTF-8 encodings. File is aligned to a piece boundary and occurs in the same order as in the file tree. The last piece of each file may be shorter than the specified piece length, resulting in an alignment gap. \"length\": Length of the file in bytes. Presence of this field indicates that the dictionary describes a file, not a directory. Which means it must not have any sibling entries. \"pieces root\": For non-empty files this is the the root hash of a merkle tree with a branching factor of 2, constructed from 16KiB blocks of the file. The last block may be shorter than 16KiB. The remaining leaf hashes beyond the end of the file required to construct upper layers of the merkle tree are set to zero. As of meta version 2 SHA2-256 is used as digest function for the merkle tree. The hash is stored in its binary form, not as human-readable string. \"piece layers\": A dictionary of strings. For each file in the file tree that is larger than the piece size it contains one string value. The keys are the merkle roots while the values consist of concatenated hashes of one layer within that merkle tree. The layer is chosen so that one hash covers piece length bytes. For example if the piece size is 16KiB then the leaf hashes are used. If a piece size of 128KiB is used then 3rd layer up from the leaf hashes is used. Layer hashes which exclusively cover data beyond the end of file, i.e. are only needed to balance the tree, are omitted. All hashes are stored in their binary format. A torrent is not valid if this field is absent, the contained hashes do not match the merkle roots or are not from the correct layer. The file tree root dictionary itself must not be a file, i.e. it must not contain a zero-length key with a dictionary containing a length key. From Bittorrent.org Documentation pages. Metainfo files (also known as .torrent files) are bencoded dictionaries with the following keys: announce The URL of the tracker. info This maps to a dictionary, with keys described below. All strings in a .torrent file that contains text must be UTF-8 encoded.","title":"Notes"},{"location":"torrent/#torrentfile.torrent--info-dictionary","text":"The name key maps to a UTF-8 encoded string which is the suggested name to save the file (or directory) as. It is purely advisory. piece length maps to the number of bytes in each piece the file is split into. For the purposes of transfer, files are split into fixed-size pieces which are all the same length except for possibly the last one which may be truncated. piece length is almost always a power of two, most commonly 2 18 = 256 K (BitTorrent prior to version 3.2 uses 2 20 = 1 M as default). pieces maps to a string whose length is a multiple of 20. It is to be subdivided into strings of length 20, each of which is the SHA1 hash of the piece at the corresponding index. There is also a key length or a key files , but not both or neither. If length is present then the download represents a single file, otherwise it represents a set of files which go in a directory structure. In the single file case, length maps to the length of the file in bytes. For the purposes of the other keys, the multi-file case is treated as only having a single file by concatenating the files in the order they appear in the files list. The files list is the value files maps to, and is a list of dictionaries containing the following keys: length - The length of the file, in bytes. path - A list of UTF-8 encoded strings corresponding to subdirectory names, the last of which is the actual file name (a zero length list is an error case). In the single file case, the name key is the name of a file, in the muliple file case, it's the name of a directory.","title":"info dictionary"},{"location":"torrent/#torrentfile.torrent.MetaFile","text":"Base Class for all TorrentFile classes. Parameters: Name Type Description Default path `str` target path to torrent content. required announce `str` One or more tracker URL's. required comment `str` A comment. required piece_length `int` Size of torrent pieces. required private `bool` For private trackers? required outfile `str` target path to write .torrent file. required source `str` Private tracker source. required","title":"MetaFile"},{"location":"torrent/#torrentfile.torrent.MetaFile.__init__","text":"Construct MetaFile superclass and assign local attributes. Source code in torrentfile\\torrent.py def __init__ ( self , path = None , announce = None , private = False , source = None , piece_length = None , comment = None , outfile = None , ): \"\"\"Construct MetaFile superclass and assign local attributes.\"\"\" if not path : raise utils . MissingPathError # base path to torrent content. self . path = path # Format piece_length attribute. if piece_length : self . piece_length = utils . normalize_piece_length ( piece_length ) else : self . piece_length = utils . path_piece_length ( self . path ) # Assign announce URL to empty string if none provided. if not announce : self . announce = \"\" self . announce_list = [[ \"\" ]] # Most torrent clients have editting trackers as a feature. elif isinstance ( announce , str ): self . announce = announce self . announce_list = [[ announce ]] elif isinstance ( announce , Sequence ): self . announce = announce [ 0 ] self . announce_list = [[ i ] for i in announce ] if private : self . private = 1 else : self . private = private self . source = source self . comment = comment self . outfile = outfile self . meta = { \"announce\" : self . announce , \"announce list\" : self . announce_list , \"created by\" : f \"TorrentFile:v { version } \" , \"creation date\" : int ( datetime . timestamp ( datetime . now ())), \"info\" : {}, } if self . comment : self . meta [ \"info\" ][ \"comment\" ] = self . comment if self . private : self . meta [ \"info\" ][ \"private\" ] = self . private if self . source : self . meta [ \"info\" ][ \"source\" ] = self . source self . meta [ \"info\" ][ \"name\" ] = os . path . basename ( self . path ) self . meta [ \"info\" ][ \"piece length\" ] = self . piece_length","title":"__init__()"},{"location":"torrent/#torrentfile.torrent.MetaFile.assemble","text":"Overload in subclasses. Source code in torrentfile\\torrent.py def assemble ( self ): \"\"\"Overload in subclasses. Raises: NotImplementedError (`Exception`) \"\"\" raise NotImplementedError","title":"assemble()"},{"location":"torrent/#torrentfile.torrent.MetaFile.sort_meta","text":"Sort the info and meta dictionaries. Source code in torrentfile\\torrent.py def sort_meta ( self ): \"\"\"Sort the info and meta dictionaries.\"\"\" meta = self . meta meta [ \"info\" ] = dict ( sorted ( list ( meta [ \"info\" ] . items ()))) meta = dict ( sorted ( list ( meta . items ()))) return meta","title":"sort_meta()"},{"location":"torrent/#torrentfile.torrent.MetaFile.write","text":"Write meta information to .torrent file. Parameters: Name Type Description Default outfile `str`, default=None Destination path for .torrent file. None Returns: Type Description outfile (`str`) Where the .torrent file was writen. meta ( dict ): .torrent meta information. Source code in torrentfile\\torrent.py def write ( self , outfile = None ): \"\"\"Write meta information to .torrent file. Args: outfile (`str`, default=None): Destination path for .torrent file. Returns: outfile (`str`): Where the .torrent file was writen. meta (`dict`): .torrent meta information. \"\"\" if outfile is not None : self . outfile = outfile if self . outfile is None : self . outfile = str ( self . path ) + \".torrent\" self . meta = self . sort_meta () pyben . dump ( self . meta , self . outfile ) return self . outfile , self . meta","title":"write()"},{"location":"torrent/#torrentfile.torrent.TorrentFile","text":"Class for creating Bittorrent meta files. Construct Torrentfile class instance object. Parameters: Name Type Description Default path(`str`) Path to torrent file or directory. required piece_length(`int`) Size of each piece of torrent data. required announce(`str` or `list` One or more tracker URL's. required private(`int`) 1 if private torrent else 0. required source(`str`) Source tracker. required comment(`str`) Comment string. required outfile(`str`) Path to write metfile to. required","title":"TorrentFile"},{"location":"torrent/#torrentfile.torrent.TorrentFile.__init__","text":"Construct TorrentFile instance with given keyword args. Parameters: Name Type Description Default kwargs `dict` dictionary of keyword args passed to superclass. {} Source code in torrentfile\\torrent.py def __init__ ( self , ** kwargs ): \"\"\"Construct TorrentFile instance with given keyword args. Args: kwargs (`dict`): dictionary of keyword args passed to superclass. \"\"\" super () . __init__ ( ** kwargs ) logging . debug ( \"Making Bittorrent V1 meta file.\" ) self . assemble ()","title":"__init__()"},{"location":"torrent/#torrentfile.torrent.TorrentFile.assemble","text":"Assemble components of torrent metafile. Returns: Type Description `dict` metadata dictionary for torrent file Source code in torrentfile\\torrent.py def assemble ( self ): \"\"\"Assemble components of torrent metafile. Returns: `dict`: metadata dictionary for torrent file \"\"\" info = self . meta [ \"info\" ] size , filelist = utils . filelist_total ( self . path ) if os . path . isfile ( self . path ): info [ \"length\" ] = size else : info [ \"files\" ] = [ { \"length\" : os . path . getsize ( path ), \"path\" : os . path . relpath ( path , self . path ) . split ( os . sep ), } for path in filelist ] pieces = bytearray () feeder = Hasher ( filelist , self . piece_length ) for piece in feeder : pieces . extend ( piece ) info [ \"pieces\" ] = pieces","title":"assemble()"},{"location":"torrent/#torrentfile.torrent.TorrentFileHybrid","text":"Construct the Hybrid torrent meta file with provided parameters. Parameters: Name Type Description Default path `str` path to torrentfile target. required announce `str` or `list` one or more tracker URL's. required comment `str` Some comment. required source `str` Used for private trackers. required outfile `str` target path to write output. required private `bool` Used for private trackers. required piece_length `int` torrentfile data piece length. required","title":"TorrentFileHybrid"},{"location":"torrent/#torrentfile.torrent.TorrentFileHybrid.__init__","text":"Create Bittorrent v1 v2 hybrid metafiles. Source code in torrentfile\\torrent.py def __init__ ( self , ** kwargs ): \"\"\"Create Bittorrent v1 v2 hybrid metafiles.\"\"\" super () . __init__ ( ** kwargs ) logging . debug ( \"Creating Hybrid torrent file.\" ) self . name = os . path . basename ( self . path ) self . hashes = [] self . piece_layers = {} self . pieces = [] self . files = [] self . assemble ()","title":"__init__()"},{"location":"torrent/#torrentfile.torrent.TorrentFileHybrid.assemble","text":"Assemble the parts of the torrentfile into meta dictionary. Source code in torrentfile\\torrent.py def assemble ( self ): \"\"\"Assemble the parts of the torrentfile into meta dictionary.\"\"\" info = self . meta [ \"info\" ] info [ \"meta version\" ] = 2 if os . path . isfile ( self . path ): info [ \"file tree\" ] = { self . name : self . _traverse ( self . path )} info [ \"length\" ] = os . path . getsize ( self . path ) else : info [ \"file tree\" ] = self . _traverse ( self . path ) info [ \"files\" ] = self . files info [ \"pieces\" ] = b \"\" . join ( self . pieces ) self . meta [ \"piece layers\" ] = self . piece_layers return info","title":"assemble()"},{"location":"torrent/#torrentfile.torrent.TorrentFileV2","text":"Class for creating Bittorrent meta v2 files. Parameters: Name Type Description Default path `str` Path to torrent file or directory. required piece_length `int` Size of each piece of torrent data. required announce `str` or `list` one or more tracker URL's. required private `int` 1 if private torrent else 0. required source `str` Source tracker. required comment `str` Comment string. required outfile `str` Path to write metfile to. required","title":"TorrentFileV2"},{"location":"torrent/#torrentfile.torrent.TorrentFileV2.__init__","text":"Construct TorrentFileV2 Class instance from given parameters. Parameters: Name Type Description Default kwargs `dict` keywword arguments to pass to superclass. {} Source code in torrentfile\\torrent.py def __init__ ( self , ** kwargs ): \"\"\"Construct `TorrentFileV2` Class instance from given parameters. Args: kwargs (`dict`): keywword arguments to pass to superclass. \"\"\" super () . __init__ ( ** kwargs ) logging . debug ( \"Create .torrent v2 file.\" ) self . piece_layers = {} self . hashes = [] self . assemble ()","title":"__init__()"},{"location":"torrent/#torrentfile.torrent.TorrentFileV2.assemble","text":"Assemble then return the meta dictionary for encoding. Returns: Type Description meta (`dict`) Metainformation about the torrent. Source code in torrentfile\\torrent.py def assemble ( self ): \"\"\"Assemble then return the meta dictionary for encoding. Returns: meta (`dict`): Metainformation about the torrent. \"\"\" info = self . meta [ \"info\" ] if os . path . isfile ( self . path ): info [ \"file tree\" ] = { info [ \"name\" ]: self . _traverse ( self . path )} info [ \"length\" ] = os . path . getsize ( self . path ) else : info [ \"file tree\" ] = self . _traverse ( self . path ) info [ \"meta version\" ] = 2 self . meta [ \"piece layers\" ] = self . piece_layers module torrentfile. torrent Base and Subclasses for bittorrent meta files. This module metafile2 contains classes and functions related to constructing .torrent files using Bittorrent v2 Protocol Classes: TorrentFile : construct .torrent file. TorrentFileV2 : construct .torrent v2 files using provided data. MetaFile base class for all MetaFile classes. Constants: BLOCK_SIZE ( int ): size of leaf hashes for merkle tree. HASH_SIZE ( int ): Length of a sha256 hash. Notes Implementation details for Bittorrent Protocol v2. Metainfo files (also known as .torrent files) are bencoded dictionaries with the following keys: \"announce\": The URL of the tracker. \"info\": This maps to a dictionary, with keys described below. \"name\": A display name for the torrent. It is purely advisory. \"piece length\": The number of bytes that each logical piece in the peer protocol refers to. I.e. it sets the granularity of piece, request, bitfield and have messages. It must be a power of two and at least 6KiB. \"meta version\": An integer value, set to 2 to indicate compatibility with the current revision of this specification. Version 1 is not assigned to avoid confusion with BEP3. Future revisions will only increment this issue to indicate an incompatible change has been made, for example that hash algorithms were changed due to newly discovered vulnerabilities. Lementations must check this field first and indicate that a torrent is of a newer version than they can handle before performing other idations which may result in more general messages about invalid files. Files are mapped into this piece address space so that each non-empty \"file tree\": A tree of dictionaries where dictionary keys represent UTF-8 encoded path elements. Entries with zero-length keys describe the properties of the composed path at that point. 'UTF-8 encoded' in this context only means that if the native encoding is known at creation time it must be converted to UTF-8. Keys may contain invalid UTF-8 sequences or characters and names that are reserved on specific filesystems. Implementations must be prepared to sanitize them. On most platforms path components exactly matching '.' and '..' must be sanitized since they could lead to directory traversal attacks and conflicting path descriptions. On platforms that require valid UTF-8 path components this sanitizing step must happen after normalizing overlong UTF-8 encodings. File is aligned to a piece boundary and occurs in the same order as in the file tree. The last piece of each file may be shorter than the specified piece length, resulting in an alignment gap. \"length\": Length of the file in bytes. Presence of this field indicates that the dictionary describes a file, not a directory. Which means it must not have any sibling entries. \"pieces root\": For non-empty files this is the the root hash of a merkle tree with a branching factor of 2, constructed from 16KiB blocks of the file. The last block may be shorter than 16KiB. The remaining leaf hashes beyond the end of the file required to construct upper layers of the merkle tree are set to zero. As of meta version 2 SHA2-256 is used as digest function for the merkle tree. The hash is stored in its binary form, not as human-readable string. \"piece layers\": A dictionary of strings. For each file in the file tree that is larger than the piece size it contains one string value. The keys are the merkle roots while the values consist of concatenated hashes of one layer within that merkle tree. The layer is chosen so that one hash covers piece length bytes. For example if the piece size is 16KiB then the leaf hashes are used. If a piece size of 128KiB is used then 3rd layer up from the leaf hashes is used. Layer hashes which exclusively cover data beyond the end of file, i.e. are only needed to balance the tree, are omitted. All hashes are stored in their binary format. A torrent is not valid if this field is absent, the contained hashes do not match the merkle roots or are not from the correct layer. The file tree root dictionary itself must not be a file, i.e. it must not contain a zero-length key with a dictionary containing a length key. From Bittorrent.org Documentation pages. Metainfo files (also known as .torrent files) are bencoded dictionaries with the following keys: announce The URL of the tracker. info This maps to a dictionary, with keys described below. All strings in a .torrent file that contains text must be UTF-8 encoded.","title":"assemble()"},{"location":"torrent/#info-dictionary","text":"The name key maps to a UTF-8 encoded string which is the suggested name to save the file (or directory) as. It is purely advisory. piece length maps to the number of bytes in each piece the file is split into. For the purposes of transfer, files are split into fixed-size pieces which are all the same length except for possibly the last one which may be truncated. piece length is almost always a power of two, most commonly 2 18 = 256 K (BitTorrent prior to version 3.2 uses 2 20 = 1 M as default). pieces maps to a string whose length is a multiple of 20. It is to be subdivided into strings of length 20, each of which is the SHA1 hash of the piece at the corresponding index. There is also a key length or a key files , but not both or neither. If length is present then the download represents a single file, otherwise it represents a set of files which go in a directory structure. In the single file case, length maps to the length of the file in bytes. For the purposes of the other keys, the multi-file case is treated as only having a single file by concatenating the files in the order they appear in the files list. The files list is the value files maps to, and is a list of dictionaries containing the following keys: length - The length of the file, in bytes. path - A list of UTF-8 encoded strings corresponding to subdirectory names, the last of which is the actual file name (a zero length list is an error case). In the single file case, the name key is the name of a file, in the muliple file case, it's the name of a directory. Classes MetaFile \u2014 Base Class for all TorrentFile classes. TorrentFile \u2014 Class for creating Bittorrent meta files. TorrentFileV2 \u2014 Class for creating Bittorrent meta v2 files. TorrentFileHybrid \u2014 Construct the Hybrid torrent meta file with provided parameters.","title":"info dictionary"},{"location":"utils/","text":"Documentation for Utils Module Utility functions and classes used throughout package. Functions: get_piece_length: calculate ideal piece length for torrent file. sortfiles: traverse directory in sorted order yielding paths encountered. path_size: Sum the sizes of each file in path. get_file_list: Return list of all files contained in directory. path_stat: Get ideal piece length, total size, and file list for directory. path_piece_length: Get ideal piece length based on size of directory. MissingPathError ( Exception ) Path parameter is required to specify target content. Creating a .torrent file with no contents seems rather silly. Parameters message : any Message for user (optional). __init__ ( self , message = None ) special Raise when creating a meta file without specifying target content. The message argument is a message to pass to Exception base class. Source code in torrentfile\\utils.py def __init__ ( self , message = None ): \"\"\"Raise when creating a meta file without specifying target content. The `message` argument is a message to pass to Exception base class. \"\"\" self . message = f \"Path arguement is missing and required { str ( message ) } \" super () . __init__ ( message ) PieceLengthValueError ( Exception ) Piece Length parameter must equal a perfect power of 2. Parameters message : any Message for user (optional). __init__ ( self , message = None ) special Raise when creating a meta file with incorrect piece length value. The message argument is a message to pass to Exception base class. Source code in torrentfile\\utils.py def __init__ ( self , message = None ): \"\"\"Raise when creating a meta file with incorrect piece length value. The `message` argument is a message to pass to Exception base class. \"\"\" self . message = f \"Incorrect value for piece length: { str ( message ) } \" super () . __init__ ( message ) filelist_total ( pathstring ) Perform error checking and format conversion to os.PathLike. Parameters pathstring : str An existing filesystem path. Returns os.PathLike Input path converted to bytes format. Raises MissingPathError File could not be found. Source code in torrentfile\\utils.py def filelist_total ( pathstring ): \"\"\"Perform error checking and format conversion to os.PathLike. Parameters ---------- pathstring : `str` An existing filesystem path. Returns ------- `os.PathLike` Input path converted to bytes format. Raises ------ MissingPathError File could not be found. \"\"\" if os . path . exists ( pathstring ): path = Path ( pathstring ) return _filelist_total ( path ) raise MissingPathError get_file_list ( path ) Return a sorted list of file paths contained in directory. Parameters path : str target file or directory. Returns filelist : list sorted list of file paths. Source code in torrentfile\\utils.py def get_file_list ( path ): \"\"\"Return a sorted list of file paths contained in directory. Parameters ---------- path : `str` target file or directory. Returns ------- filelist : `list` sorted list of file paths. \"\"\" _ , filelist = filelist_total ( path ) return filelist get_piece_length ( size ) Calculate the ideal piece length for bittorrent data. Parameters size : int Total bits of all files incluided in .torrent file. Returns piece_length : int Ideal peace length size arguement. Source code in torrentfile\\utils.py def get_piece_length ( size ): \"\"\"Calculate the ideal piece length for bittorrent data. Parameters ---------- size : `int` Total bits of all files incluided in .torrent file. Returns ------- piece_length : `int` Ideal peace length size arguement. \"\"\" exp = 14 while size / ( 2 ** exp ) > 200 and exp < 25 : exp += 1 return 2 ** exp humanize_bytes ( amount ) Convert integer into human readable memory sized denomination. Parameters amount : int total number of bytes. Returns str : human readable representation of the given amount of bytes. Source code in torrentfile\\utils.py def humanize_bytes ( amount ): \"\"\"Convert integer into human readable memory sized denomination. Parameters ---------- amount : `int` total number of bytes. Returns ------- `str` : human readable representation of the given amount of bytes. \"\"\" if amount < 1024 : return str ( amount ) if 1024 <= amount < 1_048_576 : return f \" { amount // 1024 } KiB\" if 1_048_576 <= amount < 1_073_741_824 : return f \" { amount // 1_048_576 } MiB\" return f \" { amount // 1073741824 } GiB\" normalize_piece_length ( piece_length ) Verify input piece_length is valid and convert accordingly. Parameters piece_length : int The piece length provided by user. Returns piece_length : int normalized piece length. Raises PieceLengthValueError : If piece length is improper value. Source code in torrentfile\\utils.py def normalize_piece_length ( piece_length ): \"\"\"Verify input piece_length is valid and convert accordingly. Parameters ---------- piece_length : `int` The piece length provided by user. Returns ------- piece_length : `int` normalized piece length. Raises ------ PieceLengthValueError : If piece length is improper value. \"\"\" if isinstance ( piece_length , str ): if piece_length . isnumeric (): piece_length = int ( piece_length ) else : raise PieceLengthValueError ( piece_length ) if 13 < piece_length < 26 : return 2 ** piece_length if piece_length <= 13 : raise PieceLengthValueError ( piece_length ) log = int ( math . log2 ( piece_length )) if 2 ** log == piece_length : return piece_length raise PieceLengthValueError path_piece_length ( path ) Calculate piece length for input path and contents. Parameters path : str The absolute path to directory and contents. Returns piece_length : int The size of pieces of torrent content. Source code in torrentfile\\utils.py def path_piece_length ( path ): \"\"\"Calculate piece length for input path and contents. Parameters ---------- path : `str` The absolute path to directory and contents. Returns ------- piece_length : `int` The size of pieces of torrent content. \"\"\" psize = path_size ( path ) return get_piece_length ( psize ) path_size ( path ) Return the total size of all files in path recursively. Parameters path : str path to target file or directory. Returns size : int total size of files. Source code in torrentfile\\utils.py def path_size ( path ): \"\"\"Return the total size of all files in path recursively. Parameters ---------- path : `str` path to target file or directory. Returns ------- size : `int` total size of files. \"\"\" total_size , _ = filelist_total ( path ) return total_size path_stat ( path ) Calculate directory statistics. Parameters path : str The path to start calculating from. Returns filelist : list List of all files contained in Directory size : int Total sum of bytes from all contents of dir piece_length : int The size of pieces of the torrent contents. Source code in torrentfile\\utils.py def path_stat ( path ): \"\"\"Calculate directory statistics. Parameters ---------- path : `str` The path to start calculating from. Returns ------- filelist : `list` List of all files contained in Directory size : `int` Total sum of bytes from all contents of dir piece_length : `int` The size of pieces of the torrent contents. \"\"\" total_size , filelist = filelist_total ( path ) piece_length = get_piece_length ( total_size ) return ( filelist , total_size , piece_length ) module torrentfile. utils Utility functions and classes used throughout package. Functions: get_piece_length: calculate ideal piece length for torrent file. sortfiles: traverse directory in sorted order yielding paths encountered. path_size: Sum the sizes of each file in path. get_file_list: Return list of all files contained in directory. path_stat: Get ideal piece length, total size, and file list for directory. path_piece_length: Get ideal piece length based on size of directory. Classes MissingPathError \u2014 Path parameter is required to specify target content. PieceLengthValueError \u2014 Piece Length parameter must equal a perfect power of 2. Functions filelist_total ( pathstring ) (`os.PathLike`) \u2014 Perform error checking and format conversion to os.PathLike. get_file_list ( path ) (filelist : `list`) \u2014 Return a sorted list of file paths contained in directory. get_piece_length ( size ) (piece_length : `int`) \u2014 Calculate the ideal piece length for bittorrent data. humanize_bytes ( amount ) (`str` :) \u2014 Convert integer into human readable memory sized denomination. normalize_piece_length ( piece_length ) (piece_length : `int`) \u2014 Verify input piece_length is valid and convert accordingly. path_piece_length ( path ) (piece_length : `int`) \u2014 Calculate piece length for input path and contents. path_size ( path ) (size : `int`) \u2014 Return the total size of all files in path recursively. path_stat ( path ) (filelist : `list`) \u2014 Calculate directory statistics.","title":"Documentation for `Utils` Module"},{"location":"utils/#documentation-for-utils-module","text":"Utility functions and classes used throughout package. Functions: get_piece_length: calculate ideal piece length for torrent file. sortfiles: traverse directory in sorted order yielding paths encountered. path_size: Sum the sizes of each file in path. get_file_list: Return list of all files contained in directory. path_stat: Get ideal piece length, total size, and file list for directory. path_piece_length: Get ideal piece length based on size of directory.","title":"Documentation for Utils Module"},{"location":"utils/#torrentfile.utils.MissingPathError","text":"Path parameter is required to specify target content. Creating a .torrent file with no contents seems rather silly.","title":"MissingPathError"},{"location":"utils/#torrentfile.utils.MissingPathError--parameters","text":"message : any Message for user (optional).","title":"Parameters"},{"location":"utils/#torrentfile.utils.MissingPathError.__init__","text":"Raise when creating a meta file without specifying target content. The message argument is a message to pass to Exception base class. Source code in torrentfile\\utils.py def __init__ ( self , message = None ): \"\"\"Raise when creating a meta file without specifying target content. The `message` argument is a message to pass to Exception base class. \"\"\" self . message = f \"Path arguement is missing and required { str ( message ) } \" super () . __init__ ( message )","title":"__init__()"},{"location":"utils/#torrentfile.utils.PieceLengthValueError","text":"Piece Length parameter must equal a perfect power of 2.","title":"PieceLengthValueError"},{"location":"utils/#torrentfile.utils.PieceLengthValueError--parameters","text":"message : any Message for user (optional).","title":"Parameters"},{"location":"utils/#torrentfile.utils.PieceLengthValueError.__init__","text":"Raise when creating a meta file with incorrect piece length value. The message argument is a message to pass to Exception base class. Source code in torrentfile\\utils.py def __init__ ( self , message = None ): \"\"\"Raise when creating a meta file with incorrect piece length value. The `message` argument is a message to pass to Exception base class. \"\"\" self . message = f \"Incorrect value for piece length: { str ( message ) } \" super () . __init__ ( message )","title":"__init__()"},{"location":"utils/#torrentfile.utils.filelist_total","text":"Perform error checking and format conversion to os.PathLike.","title":"filelist_total()"},{"location":"utils/#torrentfile.utils.filelist_total--parameters","text":"pathstring : str An existing filesystem path.","title":"Parameters"},{"location":"utils/#torrentfile.utils.filelist_total--returns","text":"os.PathLike Input path converted to bytes format.","title":"Returns"},{"location":"utils/#torrentfile.utils.filelist_total--raises","text":"MissingPathError File could not be found. Source code in torrentfile\\utils.py def filelist_total ( pathstring ): \"\"\"Perform error checking and format conversion to os.PathLike. Parameters ---------- pathstring : `str` An existing filesystem path. Returns ------- `os.PathLike` Input path converted to bytes format. Raises ------ MissingPathError File could not be found. \"\"\" if os . path . exists ( pathstring ): path = Path ( pathstring ) return _filelist_total ( path ) raise MissingPathError","title":"Raises"},{"location":"utils/#torrentfile.utils.get_file_list","text":"Return a sorted list of file paths contained in directory.","title":"get_file_list()"},{"location":"utils/#torrentfile.utils.get_file_list--parameters","text":"path : str target file or directory.","title":"Parameters"},{"location":"utils/#torrentfile.utils.get_file_list--returns","text":"filelist : list sorted list of file paths. Source code in torrentfile\\utils.py def get_file_list ( path ): \"\"\"Return a sorted list of file paths contained in directory. Parameters ---------- path : `str` target file or directory. Returns ------- filelist : `list` sorted list of file paths. \"\"\" _ , filelist = filelist_total ( path ) return filelist","title":"Returns"},{"location":"utils/#torrentfile.utils.get_piece_length","text":"Calculate the ideal piece length for bittorrent data.","title":"get_piece_length()"},{"location":"utils/#torrentfile.utils.get_piece_length--parameters","text":"size : int Total bits of all files incluided in .torrent file.","title":"Parameters"},{"location":"utils/#torrentfile.utils.get_piece_length--returns","text":"piece_length : int Ideal peace length size arguement. Source code in torrentfile\\utils.py def get_piece_length ( size ): \"\"\"Calculate the ideal piece length for bittorrent data. Parameters ---------- size : `int` Total bits of all files incluided in .torrent file. Returns ------- piece_length : `int` Ideal peace length size arguement. \"\"\" exp = 14 while size / ( 2 ** exp ) > 200 and exp < 25 : exp += 1 return 2 ** exp","title":"Returns"},{"location":"utils/#torrentfile.utils.humanize_bytes","text":"Convert integer into human readable memory sized denomination.","title":"humanize_bytes()"},{"location":"utils/#torrentfile.utils.humanize_bytes--parameters","text":"amount : int total number of bytes.","title":"Parameters"},{"location":"utils/#torrentfile.utils.humanize_bytes--returns","text":"str : human readable representation of the given amount of bytes. Source code in torrentfile\\utils.py def humanize_bytes ( amount ): \"\"\"Convert integer into human readable memory sized denomination. Parameters ---------- amount : `int` total number of bytes. Returns ------- `str` : human readable representation of the given amount of bytes. \"\"\" if amount < 1024 : return str ( amount ) if 1024 <= amount < 1_048_576 : return f \" { amount // 1024 } KiB\" if 1_048_576 <= amount < 1_073_741_824 : return f \" { amount // 1_048_576 } MiB\" return f \" { amount // 1073741824 } GiB\"","title":"Returns"},{"location":"utils/#torrentfile.utils.normalize_piece_length","text":"Verify input piece_length is valid and convert accordingly.","title":"normalize_piece_length()"},{"location":"utils/#torrentfile.utils.normalize_piece_length--parameters","text":"piece_length : int The piece length provided by user.","title":"Parameters"},{"location":"utils/#torrentfile.utils.normalize_piece_length--returns","text":"piece_length : int normalized piece length.","title":"Returns"},{"location":"utils/#torrentfile.utils.normalize_piece_length--raises","text":"PieceLengthValueError : If piece length is improper value. Source code in torrentfile\\utils.py def normalize_piece_length ( piece_length ): \"\"\"Verify input piece_length is valid and convert accordingly. Parameters ---------- piece_length : `int` The piece length provided by user. Returns ------- piece_length : `int` normalized piece length. Raises ------ PieceLengthValueError : If piece length is improper value. \"\"\" if isinstance ( piece_length , str ): if piece_length . isnumeric (): piece_length = int ( piece_length ) else : raise PieceLengthValueError ( piece_length ) if 13 < piece_length < 26 : return 2 ** piece_length if piece_length <= 13 : raise PieceLengthValueError ( piece_length ) log = int ( math . log2 ( piece_length )) if 2 ** log == piece_length : return piece_length raise PieceLengthValueError","title":"Raises"},{"location":"utils/#torrentfile.utils.path_piece_length","text":"Calculate piece length for input path and contents.","title":"path_piece_length()"},{"location":"utils/#torrentfile.utils.path_piece_length--parameters","text":"path : str The absolute path to directory and contents.","title":"Parameters"},{"location":"utils/#torrentfile.utils.path_piece_length--returns","text":"piece_length : int The size of pieces of torrent content. Source code in torrentfile\\utils.py def path_piece_length ( path ): \"\"\"Calculate piece length for input path and contents. Parameters ---------- path : `str` The absolute path to directory and contents. Returns ------- piece_length : `int` The size of pieces of torrent content. \"\"\" psize = path_size ( path ) return get_piece_length ( psize )","title":"Returns"},{"location":"utils/#torrentfile.utils.path_size","text":"Return the total size of all files in path recursively.","title":"path_size()"},{"location":"utils/#torrentfile.utils.path_size--parameters","text":"path : str path to target file or directory.","title":"Parameters"},{"location":"utils/#torrentfile.utils.path_size--returns","text":"size : int total size of files. Source code in torrentfile\\utils.py def path_size ( path ): \"\"\"Return the total size of all files in path recursively. Parameters ---------- path : `str` path to target file or directory. Returns ------- size : `int` total size of files. \"\"\" total_size , _ = filelist_total ( path ) return total_size","title":"Returns"},{"location":"utils/#torrentfile.utils.path_stat","text":"Calculate directory statistics.","title":"path_stat()"},{"location":"utils/#torrentfile.utils.path_stat--parameters","text":"path : str The path to start calculating from.","title":"Parameters"},{"location":"utils/#torrentfile.utils.path_stat--returns","text":"filelist : list List of all files contained in Directory size : int Total sum of bytes from all contents of dir piece_length : int The size of pieces of the torrent contents. Source code in torrentfile\\utils.py def path_stat ( path ): \"\"\"Calculate directory statistics. Parameters ---------- path : `str` The path to start calculating from. Returns ------- filelist : `list` List of all files contained in Directory size : `int` Total sum of bytes from all contents of dir piece_length : `int` The size of pieces of the torrent contents. \"\"\" total_size , filelist = filelist_total ( path ) piece_length = get_piece_length ( total_size ) return ( filelist , total_size , piece_length ) module torrentfile. utils Utility functions and classes used throughout package. Functions: get_piece_length: calculate ideal piece length for torrent file. sortfiles: traverse directory in sorted order yielding paths encountered. path_size: Sum the sizes of each file in path. get_file_list: Return list of all files contained in directory. path_stat: Get ideal piece length, total size, and file list for directory. path_piece_length: Get ideal piece length based on size of directory. Classes MissingPathError \u2014 Path parameter is required to specify target content. PieceLengthValueError \u2014 Piece Length parameter must equal a perfect power of 2. Functions filelist_total ( pathstring ) (`os.PathLike`) \u2014 Perform error checking and format conversion to os.PathLike. get_file_list ( path ) (filelist : `list`) \u2014 Return a sorted list of file paths contained in directory. get_piece_length ( size ) (piece_length : `int`) \u2014 Calculate the ideal piece length for bittorrent data. humanize_bytes ( amount ) (`str` :) \u2014 Convert integer into human readable memory sized denomination. normalize_piece_length ( piece_length ) (piece_length : `int`) \u2014 Verify input piece_length is valid and convert accordingly. path_piece_length ( path ) (piece_length : `int`) \u2014 Calculate piece length for input path and contents. path_size ( path ) (size : `int`) \u2014 Return the total size of all files in path recursively. path_stat ( path ) (filelist : `list`) \u2014 Calculate directory statistics.","title":"Returns"}]}